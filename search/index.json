[{"content":" 流水线CPU设计方案 概述 本次课下我根据P4的代码进行了大规模重构，加入了五级流水线寄存器和转发的控制通路，最后针对转发和阻塞编写了冒险处理模块。\n指令说明 本文实现的CPU包含的指令与P4相同。\nR型指令 add sub jr 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui J型指令 jal 空指令 nop 功能模块设计（含流水线寄存器） 以下功能模块排列按照所在阶段从前往后排布。\nIFU 相对P4，加入了使能信号和PC+8的值，分别是为了应对阻塞时冻结PC和跳转延迟槽的问题。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 en input 使能信号 1 next_pc input 下一个指令地址 32 PC output 当前指令地址寄存器 32 instr output 当前指令 32 PC_8 output 当前指令地址 + 8 的值 32 IF_ID 第一个流水线寄存器。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 en input 使能信号 1 F_instr input 取指阶段的当前指令 32 F_PC input 取指阶段的当前指令地址寄存器 32 F_PC8 input 取指阶段的当前指令地址 + 8 32 D_instr output 译码阶段的当前指令 32 D_PC output 译码阶段的当前指令地址寄存器 32 D_PC8 output 译码阶段的当前指令地址 + 8 32 Controller 加入了新信号Tuse和Tnew的产生逻辑，这两个信号将用于判断阻塞，后面将会详细分析。\n信号名 方向 描述 位宽 opcode input 操作码，决定操作类型 6 funct input 功能码，辅助操作码决定功能 6 NPCOp output 下一个PC的操作码选择 3 RegWrite output 寄存器写使能信号 1 ALUOp output ALU操作选择信号 3 MemWrite output 内存写使能信号 1 ExtOp output 符号扩展操作选择 1 WAOp output 写地址选择信号 2 WDOp output 写数据选择信号 2 BOp output 分支操作信号 1 Tuse output 使用时间信号 2 Tnew output 新数据时间信号 2 NPC NPC是个特殊的模块，因为他不严格位于某个特定的阶段，他的输入既有F阶段的PC，也有D阶段的PC，所以编写具体逻辑的时候需要考虑，例如b和j型指令在跳转时要用到的是PC+8而非PC+4。\n信号名 方向 描述 位宽 F_PC input 取指阶段的当前指令地址寄存器 32 D_PC input 译码阶段的当前指令地址寄存器 32 offset input 分支偏移量 16 instr_26 input 跳转指令的地址 26 ra_data input 返回地址寄存器数据 32 zero input 零标志信号 1 NPCOp input 下一个PC的操作码选择 3 next_pc output 计算出的下一个指令地址 32 GRF 几乎不变的模块。注意这里如果把always @(posedge)换成always @(negedge)就等同于实现寄存器内部转发。不过这种操作显得有些邪道了（），而且寄存器内部转发也不麻烦，所以我没有采用。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 RegWrite input 寄存器写使能信号 1 RA1 input 读寄存器地址1 5 RA2 input 读寄存器地址2 5 WA input 写寄存器地址 5 WD input 写入的数据 32 RD1 output 读出的数据1 32 RD2 output 读出的数据2 32 PC input 当前指令地址，用于显示 32 CMP 为了提高BEQ的运行效率特意准备的模块，小小的可爱捏。\n信号名 方向 描述 位宽 D1 input 第一个比较数据 32 D2 input 第二个比较数据 32 out output 比较结果，1表示相等，0表示不相等 1 ID_EX 这真是一个大到可怕的模块（），因为前一个步骤产生的控制信号和运算信号太多了，当然也有我为了可扩展性而加入的一些无用信号有关。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 clr input 清除信号 1 D_PC input 译码阶段的当前指令地址 32 D_PC8 input 译码阶段的当前指令地址 + 8 32 D_RD1 input 译码阶段读出的数据1 32 D_RD2 input 译码阶段读出的数据2 32 D_extimm input 译码阶段扩展后的立即数 32 D_Funct input 译码阶段功能码 6 D_rs input 译码阶段的源寄存器地址1 5 D_rt input 译码阶段的源寄存器地址2 5 D_rd input 译码阶段的目的寄存器地址 5 D_offset input 译码阶段的偏移量 16 E_PC output 执行阶段的当前指令地址 32 E_PC8 output 执行阶段的当前指令地址 + 8 32 E_RD1 output 执行阶段的读出数据1 32 E_RD2 output 执行阶段的读出数据2 32 E_extimm output 执行阶段扩展后的立即数 32 E_Funct output 执行阶段功能码 6 E_rs output 执行阶段的源寄存器地址1 5 E_rt output 执行阶段的源寄存器地址2 5 E_rd output 执行阶段的目的寄存器地址 5 E_offset output 执行阶段的偏移量 16 D_RegWrite input 译码阶段的寄存器写使能信号 1 D_ALUOp input 译码阶段的ALU操作选择信号 3 D_MemWrite input 译码阶段的内存写使能信号 1 D_WAOp input 译码阶段的写地址选择信号 2 D_WDOp input 译码阶段的写数据选择信号 2 D_BOp input 译码阶段的分支操作信号 1 E_RegWrite output 执行阶段的寄存器写使能信号 1 E_ALUOp output 执行阶段的ALU操作选择信号 3 E_MemWrite output 执行阶段的内存写使能信号 1 E_WAOp output 执行阶段的写地址选择信号 2 E_WDOp output 执行阶段的写数据选择信号 2 E_BOp output 执行阶段的分支操作信号 1 Tnew input 新数据时间信号 2 E_Tnew output 执行阶段的新数据时间信号 2 ALU 和我P4设计文档对比可以看出判断是否相等的zero信号不在ALU里实现了，因为我单独定义了CMP模块。\n信号名 方向 描述 位宽 ALUOp input ALU操作选择信号 3 A input 第一个操作数 32 B input 第二个操作数 32 ALU_res output ALU运算结果 32 EX_MEM 继续往前传。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 E_ALU_res input 执行阶段的ALU运算结果 32 E_PC input 执行阶段的当前指令地址 32 E_PC_8 input 执行阶段的当前指令地址 + 8 32 E_MemWD input 执行阶段的内存写数据 32 E_WA input 执行阶段的写地址 5 E_offset input 执行阶段的偏移量 16 M_ALU_res output 存储阶段的ALU运算结果 32 M_PC output 存储阶段的当前指令地址 32 M_PC_8 output 存储阶段的当前指令地址 + 8 32 M_MemWD output 存储阶段的内存写数据 32 M_WA output 存储阶段的写地址 5 M_offset output 存储阶段的偏移量 16 E_RegWrite input 执行阶段的寄存器写使能信号 1 E_MemWrite input 执行阶段的内存写使能信号 1 E_WAOp input 执行阶段的写地址选择信号 2 E_WDOp input 执行阶段的写数据选择信号 2 M_RegWrite output 存储阶段的寄存器写使能信号 1 M_MemWrite output 存储阶段的内存写使能信号 1 M_WAOp output 存储阶段的写地址选择信号 2 M_WDOp output 存储阶段的写数据选择信号 2 E_Tnew input 执行阶段的新数据时间信号 2 M_Tnew output 存储阶段的新数据时间信号 2 DM 不变。\n信号名 方向 描述 位宽 PC input 当前指令地址，用于显示 32 clk input 时钟信号 1 reset input 复位信号 1 MemWrite input 内存写使能信号 1 WA input 写地址 32 WD input 写入的数据 32 RD output 读出的数据 32 MEM_WB 前进。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC input 存储阶段的当前指令地址 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_MemRD input 存储阶段的内存读取数据 32 M_WA input 存储阶段的写地址 5 M_offset input 存储阶段的偏移量 16 W_ALU_res output 回写阶段的ALU运算结果 32 W_PC output 回写阶段的当前指令地址 32 W_PC_8 output 回写阶段的当前指令地址 + 8 32 W_MemRD output 回写阶段的内存读取数据 32 W_WA output 回写阶段的写地址 5 W_offset output 回写阶段的偏移量 16 M_RegWrite input 存储阶段的寄存器写使能信号 1 M_WAOp input 存储阶段的写地址选择信号 2 M_WDOp input 存储阶段的写数据选择信号 2 W_RegWrite output 回写阶段的寄存器写使能信号 1 W_WAOp output 回写阶段的写地址选择信号 2 W_WDOp output 回写阶段的写数据选择信号 2 M_Tnew input 存储阶段的新数据时间信号 2 W_Tnew output 回写阶段的新数据时间信号 2 MUX 这个模块包含了功能部件几乎所有的非跳转MUX。和各级流水线寄存器都有关。\n信号名 方向 描述 位宽 rt input 源寄存器地址2 5 rd input 目的寄存器地址 5 WAOp input 写地址选择信号 2 MemRD input 内存读取数据 32 offset input 偏移量 16 ALU_res input ALU运算结果 32 PC_8 input 当前指令地址 + 8 32 WDOp input 写数据选择信号 2 RD2 input 读出的数据2 32 Ext_imm16 input 扩展后的16位立即数 32 BOp input 分支操作信号 1 B output 选择的操作数B 32 WD output 写入的数据 32 A3 output 写入寄存器地址 5 搭建转发数据通路 转发是P5最大的难关和主要任务。因为无脑阻塞可以速杀几乎所有的问题，但为了通过评测，必须使用转发来提高运行效率！\n我对每一个接收转发的位置都构建了对应的转发模块，这使得结构清晰。\nForwardRD1 处理从E级、M级和W级到D_RD1的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 E_PC_8 input 执行阶段的当前指令地址 + 8 32 E_offset input 执行阶段的偏移量 16 E_WDOp input 执行阶段的写数据选择信号 2 D_RD1 input 译码阶段读出的数据1 32 Fwd_RD1Op input 转发选择控制信号 3 Fwd_RD1 output 转发后的数据 32 ForwardRD2 处理从E级、M级和W级到D_RD2的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 E_PC_8 input 执行阶段的当前指令地址 + 8 32 E_offset input 执行阶段的偏移量 16 E_WDOp input 执行阶段的写数据选择信号 2 D_RD2 input 译码阶段读出的数据2 32 Fwd_RD2Op input 转发选择控制信号 3 Fwd_RD2 output 转发后的数据 32 ForwardA 处理从M级和W级到E_A的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 A input 原始操作数A 32 Fwd_AOp input 转发选择控制信号 3 Fwd_A output 转发后的数据 32 ForwardB 处理从M级和W级到E_B的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 B input 原始操作数B 32 Fwd_BOp input 转发选择控制信号 3 Fwd_B output 转发后的数据 32 转发、阻塞信号的生成思路 我的转发和阻塞控制信号由同一个控制模块HazardUnit产生。通过输入所需要的信息，产生控制对应寄存器进行阻塞（即插入NOP指令）和控制转发模块选择正确转发数据的信号。\n信号名 方向 描述 位宽 D_RegWrite input 译码阶段的寄存器写使能信号 1 E_RegWrite input 执行阶段的寄存器写使能信号 1 M_RegWrite input 存储阶段的寄存器写使能信号 1 W_RegWrite input 回写阶段的寄存器写使能信号 1 D_rs input 译码阶段的源寄存器地址1 5 D_rt input 译码阶段的源寄存器地址2 5 E_rs input 执行阶段的源寄存器地址1 5 E_rt input 执行阶段的源寄存器地址2 5 E_WDOp input 执行阶段的写数据选择信号 2 E_WA input 执行阶段的写地址 5 M_WA input 存储阶段的写地址 5 M_WDOp input 存储阶段的写数据选择信号 2 W_WA input 回写阶段的写地址 5 Fwd_RD1Op output 译码阶段读出数据1的转发控制信号 3 Fwd_RD2Op output 译码阶段读出数据2的转发控制信号 3 Fwd_AOp output 执行阶段操作数A的转发控制信号 3 Fwd_BOp output 执行阶段操作数B的转发控制信号 3 Tuse input 当前指令的使用时间 2 E_Tnew input 执行阶段的新数据时间信号 2 M_Tnew input 存储阶段的新数据时间信号 2 W_Tnew input 回写阶段的新数据时间信号 2 IFU_en output 指令获取单元的使能信号 1 IF_ID_en output IF/ID流水寄存器的使能信号 1 ID_EX_clr output ID/EX流水寄存器的清除信号 1 转发控制思路 由于我们前面已经把控制信号沿流水线不断传递，所以我们只需要比对对应阶段的控制信号就可以得知应该是否应该转发、应该转发哪里的值。例如我对于A转发信号的产生逻辑如下。\n1 2 3 4 assign Fwd_AOp = (E_rs == 5\u0026#39;b0) ? 3\u0026#39;b011: (M_RegWrite \u0026amp;\u0026amp; E_rs == M_WA) ? 3\u0026#39;b010: (W_RegWrite \u0026amp;\u0026amp; E_rs == W_WA) ? 3\u0026#39;b001: 3\u0026#39;b000; 需要注意的是，我这里的控制信号并没有完全决定转发情况，因为我还有一部分选择是在转发模块内完成的，不过这里就不展示了。\n阻塞控制思路 使用Tuse、Tnew大法。\nTuse表示数据到了 D 级之后还需要多少个周期要使用，每个指令的Tuse是固定不变的。 Tnew表示数据还有多长时间产生，会随着数据的流水动态的减少。具体实现方法是每次Tnew经过流水线寄存器传递的时候做判断，如果非0则减1。\nHazardUnit模块会对D级的Tuse信号（因为课程要求一律在D级阻塞）和每一级的Tnew信号。如果Tuse \u0026lt; Tnew，那么说明当前需要的值还没有生成，必须阻塞流水线直到对应的值产生（即后续的Tnew通过递减与Tuse相等），反之，则说明可以通过转发解决，无需阻塞。\n测试方案 我在搭建和debug时手动编写了一系列测试样例，我把他合了起来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ori $ra, $0, 0xffff jal label add $s1, $ra, $0 label: lui $s0,1 add $s0,$s0,$s0 add $s0,$s0,$s0 add $s0,$s0,$s0 ori $s0,$0,1 jal bbb add $s0,$s0,$s0 add $s1,$s0,$s0 bbb: ori $s1,$0,1 jr $ra ori $s2,$0,1 jal aaa add $ra,$ra,$ra aaa: add $ra,$ra,$ra ori $s0,$0,2 ori $s1,$0,1 sw $s0,0($0) lw $s1,0($0) add $s1,$s1,$s1 add $s1,$s1,$s1 add $s1,$s1,$s1 ori $s1,$0,1 jal dest add $s1,$s1,$s1 add $s1,$s1,$s1 dest: add $s1,$s1,$s1 jr $ra nop ori $s0,$0,1 ori $s1,$0,1 beq $s1,$s0,dst add $s1,$s1,$s1 add $s1,$s1,$s1 add $s1,$s1,$s1 dst: add $s1,$s1,$s1 思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。 答：以beq为例，我们通过提前beq的数据比较使其Tuse减为0，虽然这在控制冒险角度减少了因为默认跳转不发生需要清除的指令，但也提高了阻塞率，例如在下面这一情况：\n1 2 add $s0,$s0,$s0 beq $s0,$s1,label 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？ 答：因为在存在延迟槽的情况下，跳转发生的时候下一条指令即PC+4指向的指令已经进入了流水线，只有写入PC+8而非PC+4，才能防止跳回时这条指令被重复执行。\n我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？ 答：因为如果转发数据来源于功能部件，这会拉长流水线寄存器间功能部件得到稳定输出值的时间，这会增大流水线的最小周期，从而限制流水线频率，影响运行效率，违背了流水线设计的初衷。\n我们为什么要使用 GPR 内部转发？该如何实现？ 答：因为当一个寄存器在流水线中同时被读写时会引发数据冒险，于是我们将即将写入寄存器的W_WD数据转发到读取寄存器的D_RD1、D_RD2，这样就实现了寄存器内部转发。\n我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？ 答：在我的CPU中，需求者是D级的寄存器读取值和E级的ALU输入值，供给者可能来自于：\nE级的16位立即数（lui）和PC+8（jal）。 M级的16位立即数（lui）、PC+8（jal）和ALU计算结果。 W级的写入数据。 转发数据通路包括：\nE到D M到D W到D M到E W到E 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。 答：我会将指令分为计算型指令、跳转型指令、访存型指令。首先是改变数据通路，和单周期类似，尽可能用现成的数据通路进行扩建（这点和P4不同，因为新增数据通路会导致必须重写大批转发）。完成数据通路之后增加对应的Tuse，Tnew和对应的控制信号。\n确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。 答：我的译码方式是集中式译码。在D级生成所有的控制信号并逐级向后传递。 优势：编写简单，速度更快，关键路径更短。 不足：没有那么模块化。\n","date":"2024-11-10T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p5-verilog%E6%90%AD%E5%BB%BA%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu/domenico-loia-hGV2TfOh0ns-unsplash_hu4086910433182145202.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p5-verilog%E6%90%AD%E5%BB%BA%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu/","title":"北航CO_P5-verilog搭建五级流水线CPU"},{"content":" 架构设计及考虑 架构设计 类图 最终程序共有22个类，其组织方式如下。\nMainClass 程序入口，调用Print进行输入解析。\nPrint 解析输入，随后调用各个方法实现功能。\nAdventure 冒险者类，因为几乎所有操作都以冒险者为主体，所以大多数功能需要这个类参与实现。\nFight 专门控制战斗的类。\nEmployment 专门控制雇佣关系的类。\nFragment 专门控制碎片的类。\nCE接口 连接冒险者游戏中的所有实体对象（均有CE）：\nAdventure Bottle父类 AtkBottle DefBottle HpBottle Equipment Guard接口 连接所有工厂中的守卫：\nShd Flm Stn Wnd Frz Treasure接口 连接所有守卫对应的宝物：\nShdTreasure FlmTreasure StnTreasure WndTreasure FrzTreasure 架构考虑 在学习了继承和接口之后，我重构了代码以增强类之间的逻辑关系，将各类药水瓶用父类形式实现，并使用接口关联起了冒险者，武器和药水瓶。在此后的工厂中也使用了接口。 对于复杂的功能，构造单独类来实现，例如Fight类，由于战斗过程复杂，单独提取出一个类，提高了代码的模块化程度。 MainClass类只用来进入程序，随后就进入Print类负责解析输入输出。 Junit心得体会 Junit单元测试是我们在OOpre课程中首次接触到的一种测试方法。他为我们提供了单独测试某个具体模块的机会，当然这机会的出现也跟java自身面向对象的特点相适应。\n在进行Junit单元测试时，我们应该进行自下而上的设计，先分别测试底层的功能能否正常实现，然后在确信底层无BUG的情况下去构造测试去测试更高层的方法，这样有利于我们快速把握问题所在。\n覆盖率是判断Junit测试有效程度的重要指标，也是OOpre课程的要求，我们今后在编写java程序时，就算没有强制要求，也应该养成保证Junit覆盖率的习惯。因为没有被测到的边边角角是最容易滋生BUG的。\nOOpre心得体会 刚开始学习OOpre的时候真的感觉非常新奇。因为面向对象编程的体验和此前完全不同。别的不说，创建一个新类后光靠代码补全就啪啪啪敲出一大堆内容的感觉真的很爽。\n不过到后期的迭代就老实了。此前我从来没有上过像OOpre这样的带有强测的课程。所以第一次需要修bug的时候真是死去活来，后面跟室友讨论才发现原来是重复携带上出了问题。不过最后一次倒是熟练了，找室友对拍了一下发现我的问题在于一次秘境探索比正常情况多闯了一关，找到对应的指令打个断点一看发现我居然携带了两个同id的药水瓶！具体问题出在哪就不说了，太丢脸。这个bug本该在第四次作业就暴露出来的。\n建议 弱测可以稍微强一点点（） ","date":"2024-11-01T00:00:00Z","image":"https://messmerr.github.io/matt-le-SJSpo9hQf7s-unsplash.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAoopre-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/","title":"北航OOpre-课程总结"},{"content":" 单周期CPU设计方案 概述 本次课下主要依靠P3的logisim进行翻译，不过我也对P3设计的一系列不合理之处进行了调整。我首先根据logisim电路图搭建各个模块，随后在mips.v文件中把各个模块合理地连接起来，最后添加controller模块产生控制信号。\n指令说明 本文实现的CPU在P3基础上添加了2条指令，即jal和jr。\nR型指令 add sub jr 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui J型指令 jal 空指令 nop 功能模块设计 IFU 将PC和IM合二为一。IM使用$readmehn语句读取code.txt文件里的指令。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 next_pc input 下一个指令地址 32 PC output 当前指令地址寄存器 32 instr output 当前指令 32 NPC 用组合逻辑计算出下一个指令的地址，通常是变为PC+4。根据控制信号不同会执行beq/jal/jr三种跳转。\n信号名 方向 描述 位宽 PC input 当前指令地址 32 offset input 分支偏移量 16 instr_26 input 指令中26位目标地址 26 ra_data input 从GRF返回的地址数据 32 zero input 分支条件标志 1 NPCOp input 下一地址选择操作码 3 next_pc output 计算后的下一指令地址 32 pc_add_4 output 当前地址加4的值 32 GRF 寄存器堆，同样是翻译即可。注意要display否则无法评测。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 RegWrite input 寄存器写入使能信号 1 RA1 input 读寄存器1地址 5 RA2 input 读寄存器2地址 5 WA input 写寄存器地址 5 WD input 写入数据 32 RD1 output 读寄存器1数据 32 RD2 output 读寄存器2数据 32 PC input 当前程序计数器地址 32 DM 数据存储器，朴实无华的读写功能。同样需要display。\n信号名 方向 描述 位宽 PC input 当前程序计数器地址 32 clk input 时钟信号 1 reset input 复位信号 1 MemWrite input 内存写入使能信号 1 WA input 写地址 32 WD input 写入数据 32 RD output 读取数据 32 ALU 本文需要的指令只需要四个运算：加、减、或。相等的判断用减法实现。\n信号名 方向 描述 位宽 ALUOp input ALU操作选择信号 3 A input ALU第一个操作数 32 B input ALU第二个操作数 32 zero output 结果是否为零标志 1 ALU_res output ALU运算结果 32 MUX 这个模块的设计和每个人自身的电路设计高度相关，我认为先建立mips.v顶层文件再构造更好。具体内容在下一部分讲解。\n信号名 方向 描述 位宽 rt input 源寄存器1地址 5 rd input 源寄存器2地址 5 WAOp input 写地址选择操作码 2 MemRD input 从内存读取的数据 32 offset input 偏移量 16 ALU_res input ALU运算结果 32 pc_add_4 input 当前PC加4的值 32 WDOp input 写数据选择操作码 2 RD2 input 第二个读寄存器的数据 32 Ext_imm16 input 扩展的16位立即数 32 BOp input B选择信号 1 B output 选择的第二个操作数 32 WD output 写入的数据 32 A3 output 写入的目标寄存器地址 5 组建数据通路 verilog组建数据通路的难度远大于logisim，因为不够直观，很容易漏接某些线。我认为比较不容易出错的设计方式如下：\n将除MUX外的所有模块放入mips.v文件中并接上所有的I/O端口。为防出错，所有的接口都用同名wire连接，可以先连好再定义这些wire型变量。 观察不同模块的接口，根据自己整理的表格/P3的电路图确定哪些端口之间是一对一连接的。使用assign语句把连接到对应端口的wire变量链接在一起。 对于需要用到多路选择器的端口，我们建立一个统一的MUX模块，这个模块负责处理所有需要进行信号选择的端口。我们将所有可能的输入信号和一会用Controller.v产生的选择信号全部作为MUX的输入，所有输出信号作为输出，内部使用条件判断语句为各个输出信号赋上对应的值。随后将其添加到mips.v中。 控制信号 建立一个新的Controller.v模块，因为CPU操作只跟指令有关，所以输入只需要opcode和funct。对于其内部结构，我喜欢先为每一条指令单独定义一个wire型变量，再以这些变量为条件去编写控制信号的生成逻辑。\n信号名 方向 描述 位宽 opcode input 指令操作码 6 funct input 功能码，用于区分操作类型 6 NPCOp output 下一地址选择操作码 3 RegWrite output 寄存器写使能信号 1 ALUOp output ALU操作码 3 MemWrite output 内存写使能信号 1 ExtOp output 立即数扩展操作选择信号 1 WAOp output 写地址选择操作码 2 WDOp output 写数据选择操作码 2 BOp output 第二操作数选择信号 1 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？ 答：addr是ALU通过将寄存器值与偏移量offset相加得到的地址信号，之所以取[11:2]是因为DM的存储是以32bit为单位，而地址信号是以8bit为单位，故略去后两位使地址信号与DM内的存储地址一致。 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣 答：指令对应的控制信号如何取值： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 case (opcode) 6\u0026#39;b000000: begin // R型指令，funct决定操作 case (funct) 6\u0026#39;b100000: begin // add RegWrite = 1; ALUOp = 3\u0026#39;b000; WAOp = 2\u0026#39;b01; NPCOp = 3\u0026#39;b0; MemWrite = 0; ExtOp = 0; WDOp = 2\u0026#39;b0; BOp = 0; end 6\u0026#39;b100010: begin // sub RegWrite = 1; ALUOp = 3\u0026#39;b001; WAOp = 2\u0026#39;b01; NPCOp = 3\u0026#39;b0; MemWrite = 0; ExtOp = 0; WDOp = 2\u0026#39;b0; BOp = 0; end //略 endcase //略 endcase 控制信号每种取值时对应的指令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 assign NPCOp = beq ? 3\u0026#39;b001: jal ? 3\u0026#39;b010: jr ? 3\u0026#39;b011: 3\u0026#39;b0; assign RegWrite = add || sub || ori || lw || lui || jal; assign ALUOp = add || lw || sw ? 3\u0026#39;b000: sub || beq ? 3\u0026#39;b001: ori ? 3\u0026#39;b010: 3\u0026#39;b111; assign MemWrite = sw; assign ExtOp = ori; assign WAOp = add || sub || jr ? 2\u0026#39;b01: jal ? 2\u0026#39;b10: 2\u0026#39;b0; assign WDOp = lw ? 2\u0026#39;b01: lui? 2\u0026#39;b10: jal? 2\u0026#39;b11: 2\u0026#39;b0; assign BOp = ori || lw || sw; 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。 答：同步复位中clk信号优先级更高，只有clk上升沿到来时reset信号才有影响，而异步复位二者地位相当，二者都可以随时生效。 C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。 答：以add与addu为例，从RTL描述中可以看出，addu就是在add的基础上增加了如果运算结果最高位和次高位不相等就抛出报错，所以如果忽略这个溢出，二者就是等价的。addi和addiu同理。 ","date":"2024-10-31T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p4-verilog%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/growtika-P5mCQ4KACbM-unsplash_hu12677493546061671520.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p4-verilog%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/","title":"北航CO_P4-verilog搭建单周期CPU"},{"content":" 单周期CPU设计方案 概述 本文使用logisim搭建了一个支持八条指令的MIPS架构CPU。开发过程首先分析所需指令的RTL，抽象出所需要的功能。然后分别建模并实现恰当的功能部件。再根据不同指令之间的关系合理地组建出简洁的数据通路。最后通过构建真值表构造控制器。\n指令说明 本文实现的CPU只包含题目要求的8条指令，但笔者在使用时进行了一些操作以增强可扩展性，下文会在相应位置介绍。\nR型指令 add sub 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui 空指令 nop 模块设计 PC 就是一个32位寄存器，没什么特别设计的。\n信号名 方向 位宽 Clk input 1 reset input 1 DI input 32 DO output 32 NPC 用组合逻辑计算出下一个指令的地址，通常是变为PC+4。对于跳转指令，本文只包含一个beq，但笔者为jal和jr留出了对应的接口。\n信号名 方向 位宽 PC input 32 imm16 input 16 imm26 input 26 A32 input 32 NPCOp input 2 Zero input 1 NPC output 32 GRF 寄存器堆，之前在P0已经设计过了。\n信号名 方向 位宽 Clk input 1 WE input 1 reset input 1 WD input 32 A1 input 5 A2 input 5 A3 input 5 RD1 output 32 RD2 output 32 IM 指令存储器，使用ROM实现，此前我因为审题不仔细导致这里卡了很久。要注意ROM的地址是以一个字为单位而不是字节，也就是说两个指令在mars中显示的地址是相隔4，用ROM表示其实只相隔1.\n信号名 方向 位宽 A input 12 D output 32 DM 数据存储器，用RAM实现。与指令存储器相比只多了一个写数据的功能。\n信号名 方向 位宽 Clk input 1 Wr input 1 A input 10 DI input 32 DO output 32 ALU 本文需要的指令只用得到四个运算：加、减、或和判断相等。其中等于可以用减来完成，减可以用补码来简化。\n信号名 方向 位宽 a input 32 b input 32 op input 2 c output 32 组建数据通路 取指令 PC与NPC实际上组成了一个MOORE型状态机，除这两个模块的所有部分都可以看成转移电路。\n图是gxp老师课件上的，实际电路NPC应该有几根线\n指令分解 纯粹体力劳动，把所有可能出现的指令部分全部分离出来。 ADDU \u0026amp; SUBU 最基础的指令，其他指令基本都是通过扩充这一部分的电路。 电路中rs、rt、rd分别给出读写指令，将运算的结果写入rd对应的寄存器中。 ORI 这一段稍微需要注意一下RTL。 由RTL知，我们要把立即数imm16作零扩展到32位后再参与或运算。同时，注意到这里需要输入GRF和ALU模块的信号与上面不同。rt作为了被写入的寄存器，同时进行运算的一个寄存器被换成了立即数。所以要在A3和B接口前使用MUX进行信号选择。每一次出现这类情况我们都用一个标签作为控制信号，最后使用打表方式一次性生成各指令的控制信号。 LW 首次出现了要对DM进行操作的指令。此时ALU的输出作为读DM的地址，DM的输出被写入对应寄存器中。此外，这里需要对立即数imm16进行的是有符号扩展，所以对EXT也要进行信号选择。 SW 写入而非读取，只需要加一个输入的数据信号和读/写控制信号即可。 BEQ 这一部分的逻辑主要是在NPC中完成的，此外只需要利用ALU的减法产生一个判断A、B是否相等的信号即可。 LUI 唯一老师上课没讲的指令，所以白嫖不了结构图了（悲伤）。 但实现非常简单，笔者将imm16拼接了一个16h'0的信号，然后直接连到GRF的WD端，配合MUX和控制信号即可。\n控制信号 为了使控制电路便于阅读和debug，我们使用或逻辑搭建电路，这样使得连线的目的非常明确。生成控制信号也许是最重要的一步，因为这一步很容易粗心。笔者就连错了一条。这里直接把我做的电路放上来。\n有人可能会问和逻辑呢？因为我用的是比较器所以省略掉了hhh。 跟上面的信号名不完全一样，仅供参考。\n测试数据 以下是我测试用过的数据，其中前一部分是pre给出的样例数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 .macro save(%dst) sw %dst,0($v0) lui $v1,0 ori $v1,$v1,4 add $v0,$v0,$v1 .end_macro ori $a0, $0, 123 ori $a1, $a0, 456 lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) sw $a3, 12($t0) sw $s0, 16($t0) sw $s1, 20($t0) sw $s2, 24($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) #以下为新写的 sub $v0,$v0,$v0 save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) sub $v0,$v0,$v0 lui $t0,0x7fff ori $t0,$t0,0xffff lui $t1,0xffff ori $t1,$t1,0xffff lui $t2,0 ori $t2,$t2,1 lui $t3,0x8000 ori $t3,$t3,0 add $s4,$t0,$t2 save($s4) add $s4,$t3,$t1 save($s4) sub $s4,$t0,$t1 save($s4) sub $s4,$t0,$t2 save($s4) lui $s0,0 beq $a1,$a1,equal ori $s0,$s0,0x1111 equal: ori $s0,$s0,1 save($s0) lui $s0,0 ori $s0,$s0,1 equal2: add $s0,$s0,$s0 beq $a1,$a1,equal2 save($s0) 除此之外，我还使用了大佬分享的评测机进行了测试和对拍。 以下是某一个随机生成的测试文件。 查看文档\n思考题 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。 答：发挥状态存储功能的模块：IFU、DM、GRF。发挥状态转移功能的模块：NPC、ALU、Control。 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。 答：合理，因为在本次的单周期CPU设计中，指令是只读的，所以使用只读的ROM进行存储。而DM需要频繁进行读写，所以使用RAM。GRF使用Register是标准设计，因为GRF本身就是寄存器堆，使用一堆寄存器搭建寄存器堆显然合理。此外，寄存器有高读写速度，适用于GRF的工作内容。 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。 答：没有。 事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？ 答：不需要。因为nop相当于sll $0,$0,0。即使在设置了sll指令时，因为这条指令并不改变寄存器值，也不会对运行产生影响。更别说我们这次的CPU压根没有实现sll指令。 阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。 答：总体来看相当弱。没有覆盖sub指令。对add指令测试了正正、正负、负负三种情况，较全面，但是没有针对极端值进行测试（虽然本CPU的add和sub不考虑溢出）。对于beq的测试也过于简单，没有测试offset和寄存器值为负和为0的情况。lw也没有针对$0寄存器作出检验。 ","date":"2024-10-23T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p3-logisim%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/pexels-jplenio-1105379_hu4455340264904558413.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p3-logisim%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/","title":"北航CO_P3-logisim搭建单周期CPU"},{"content":" 昨天晚上进行了计组P0的上机，他不是普通的上机，是国庆前夜的上机，是计组第一次影响分数的上机，这里除了6系牛马，没人配与他单挑。\n在去之前，我是十分焦虑的。这主要是北航CO的低容错所致：\n课程总计5.5学分，分为理论和实验两部分，其中实验部分占比超过2学分。 实验部分以课上为主，课上部分采取闯关制，只有通过前面的关卡才能继续挑战后面的关卡。例如你P5挂了，下一次上机别人做P6，你还是做P5，而且你并不是接着上一周的进度做，助教出了全新的三道题（快说谢谢助教），要是这次还不过，那下次继续。 根据往届的说法，前几次上机通过的要求都是AK,必须三道题全过，后面则会变成过两道即算通过。 上机难度通常不低，即使是那些公认的往届大佬都有不少挂过。 不过课程组也知道不能太为难学生，所以还是有一些保护措施，比如前几次上机不做卡关设置，没过也允许做后面的内容（我觉得这可能跟前几次上机不涉及迭代开发有关）。此外，据说再过几周会有一次整体的容错关，大家一起停一周，全过的同学无事可做，剩下的同学可以追一次进度。相当于提供了挂一次的容错。\n但是毫无疑问，即便如此上机依然是一个让人无比焦虑的事情，想想看，可能一个思路没转过来，就挂了一次上机，然后直接被大部队甩开，要是在同一关挂两次以上，那简直重开的心都有了。\n幸运的是，这次的P0是一个纯粹的奖励关。\n情况 我们寝室四个人都在开考后四十分钟至一个小时间AK交卷。同时，我交卷的时候仅我所在机房就有二十几个人排队在我前面等待签退，可见课程组发自内心的想让我们度过一个快乐的国庆。\n而且我们还发糖吃了，win。\n第一题 一道非常简单的组合逻辑的题目。要求计算一个四位四进制数的逆序数。\n在n个数码1，2，…，n的全排列j1j2…jn中，若一个较大的数码排在一个较小的数码的前面，则称它们构成逆序，这个排列的所有逆序的数量，称为这个排列的逆序数，记为τ(j1j2…jn)或π(j1j2…jn)。例如，在四个数码的排列3142中，3与1，3与2以及4与2都构成逆序，因此τ(3142)=3。逆序数为奇数的排列称为奇排列，逆序数为偶数的排列称为偶排列。\n这道题的思路连小学生看了上面的定义都知道，只需要从前往后依次比较六次，每次出现前大于后时加一即可。唯一可能需要注意的点就是比较器要设置为unsigned。\n第二题 一道非常简单的MOORE状态机的题目，只需要根据指令对两个寄存器进行简单的运算，00不变，01加1，10减1，11置0。有一个输入信号决定操作哪个寄存器。唯一需要注意的是操作一个寄存器时要保证另一个不变，这一点用使能端实现即可。\n第三题 一道简单的MOORE状态机的题目，需要输出由“0-9，a-f”构成的最长严格递增后缀子串的长度。\n例如，串abcdefg的后缀子串包括g,fg,efg,defg,cdefg,bcdefg,abcdefg。若一个后缀子串满足每一个数都比之前的数大，则称其为严格递增后缀子串。\n我的方法是使用两个寄存器，一个存储上一个数的值，另一个存储最长严格递增后缀子串的长度。状态更新非常简单，略而不表。\n","date":"2024-10-01T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Alogisim%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Alogisim%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/","title":"北航CO_P0课上——logisim的基础运用"},{"content":" FSM 这一题题干是检测是否输入的字符串是否符合给定的格式。\n具体格式是：先输入一到两个b，再输入两个a或c。\nIO In[1:0] I CLR I Z O 基本结构 Mealy状态机\n状态变量type 用寄存器表示\n状态0 如果输入b则状态为1，否则为0\n状态1 经过了Zebra同学的指点，我果断放弃了繁琐至极的原方法。 使用一个通用的计数器，输入b则判断计数器是否大于2，是则状态0且计数器置0，否则计数器增加，否则判断输入是否为a或c，都满足则计数器置1，状态2，否则状态0，同时计数器置0。 为什么不需要这个呢，因为这道题在连续输入b的时候无论几个都只需要保持状态1。\n如果输入b，保持状态1。 如果输入a或c，进入状态2。 否则变为状态0。\n状态2 如果输入b，进入状态1。 如果输入a或c，进入状态3，否则状态0。\n状态3 如果输入b，保持状态1。 如果输入a或c，进入状态0。\nPS：状态3其实是多余的，但是两位的寄存器放四个状态比较舒服\n复位 同步复位，使用MUX。\n子模块设置 状态转移模块 输入：type寄存器的输出和in 输出：type寄存器的输入\n输出模块 与常规Mealy状态机一样，本题是状态为2且输入为a或c即输出1。\n","date":"2024-09-26T19:32:28+08:00","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Bfsm/matt-le-SJSpo9hQf7s-unsplash_hu4699868770670889127.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Bfsm/","title":"北航CO_P0课下——FSM"},{"content":" 花了好几个小时总算把个人博客搭好了。至于为什么要搭这个博客，只能说人终究是从众的生物，当你看到那么多6系大佬都有自己的博客，难免会想着自己搭一个。\n此外，有一说一昨天的CO上机真是一场灾难\n考试机制 每周的考试让人回忆起高中的峥嵘岁月，CO作为北航精品课程，处处都体现出了不同于其他课程的威压：\n在新北地下机房上机，禁止携带电子设备，校园卡验明真身 只能使用学校机房电脑（这意味着不能使用任何电子资料） 机房电脑手感极度糟糕1 电脑自带程序相当有限，我的vscode上配置了基础的C环境，有verilog插件和Markdown插件，然而听有些人说他们的vscode连verilog插件都没有，语法不熟悉就直接寄 这次的考试机制是总时长三小时，其中前两个小时纯自己做，最后一个小时发出提示文件，还可以向助教提问，三道题都AC之后可以点击交卷，随后助教就会过来提几个问题（然而我因为交卷太晚助教让我直接走），结束之后就可以离开了。令人惊讶的是这次上机只要在三个小时内AK，课程平台上就一律算通过，于是像我这种三道题全是最后一小时AC的大混子也有个通过标。\n第一题 第一题是一道logisim的MOORE状态机的题目，要求根据输入的不同切换数列的递推方式，这一构造没有什么难度，只要用一个额外的寄存器存储前n项和的值即可。然而这一题最大的难点在于——同步复位。\n属于是COpre魅力时刻了，因为COpre上根本没有涉及到同步复位的设计方法，我们之前做的题全部都是异步复位。于是我的设计过程是这样的：\n首先使用异步复位，即直接把reset信号练到寄存器的复位端，四个测试点过两个。 重新审题，发现需要使用同步复位，经过短暂思考，决定把clk信号和reset信号用与门连接在一起，合成同步的reset信号，然后接到寄存器的复位端。四个测试点过三个。 然后我就卡住了（允悲）。 所以问题出在哪呢？原来是因为使用与门会导致毛刺的出现，因为延时的问题，导致clk上升沿到达寄存器和clk和reset的与到达寄存器的时间有了微妙的差异，于是就会出现先正常更新一次数据再突然复位的错误现象。\n那么这个问题如何解决呢？答案是直接放弃寄存器的复位端。直接使用MUX，以reset为选择信号，reset为0时正常输入，为1时则输入初始值。这样就保证复位一定是在clk上升沿进行了。\n先写到这里，这是第一篇博客，先push一下看看显示正常不。 OK，没问题，但是我要写P0课下了，暂时先到这里 好的，这一等就是一个星期，现在是10月1号下午五点，我正在高铁上。昨天已经把P0课上考完了。\n第二题 第二题是verilog的一道非常基础的题目。几乎只是对基础语法的一个考查。整个算法只涉及一个简单的循环，如果使用vscode插件的话基础语法的正确性也有保障。然而我依然耻辱地在这一题卡了四十分钟，因为我把阻塞赋值和非阻塞赋值搞混了。\n这确实非常不应该，因为阻塞赋值和非阻塞赋值也是COpre重点描述的内容，然而我并没有认真看（允悲）。因此我对这两东西的印象就停留在always里面用非阻塞赋值，外面的就用阻塞赋值。然而事实并非如此。事实上直到现在我也没完全弄清楚（这周实在是太摆烂了），不过我的印象也升级为了组合逻辑一定用阻塞赋值（包括always @(*)内的语句，时序逻辑才用非阻塞赋值）。\n第三题 第三题与第二题定位类似，是一道极为基础的MIPS题目，代码只涉及简单的循环，条件判断。考虑到mars的help是三款软件中最简单易懂的（写语句的时候直接把意思都标出来，他真的我哭死），只要COpre学会了就不会有问题。\n总结 总而言之这次CO上机确实是非常简单，然而正是因为它太简单才显得我在考场被卡住的样子更加狼狈。不过事后我发现周围的人情况都跟我类似，大概这是第一次上机的普遍现象吧。\n黏糊糊，且有奇妙拖拽感的鼠标，不知为何看起来很不清晰的显示屏，敲起来完全不跟手的键盘……\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-24T12:10:01+08:00","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco%E4%B8%8A%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco%E4%B8%8A%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"北航CO上机初体验"}]