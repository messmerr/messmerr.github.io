[{"content":" 单周期CPU设计方案 概述 本文使用logisim搭建了一个支持八条指令的MIPS架构CPU。开发过程首先分析所需指令的RTL，抽象出所需要的功能。然后分别建模并实现恰当的功能部件。再根据不同指令之间的关系合理地组建出简洁的数据通路。最后通过构建真值表构造控制器。\n指令说明 本文实现的CPU只包含题目要求的8条指令，但笔者在使用时进行了一些操作以增强可扩展性，下文会在相应位置介绍。\nR型指令 add sub 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui 空指令 nop 模块设计 PC 就是一个32位寄存器，没什么特别设计的。\n信号名 方向 位宽 Clk input 1 reset input 1 DI input 32 DO output 32 NPC 用组合逻辑计算出下一个指令的地址，通常是变为PC+4。对于跳转指令，本文只包含一个beq，但笔者为jal和jr留出了对应的接口。\n信号名 方向 位宽 PC input 32 imm16 input 16 imm26 input 26 A32 input 32 NPCOp input 2 Zero input 1 NPC output 32 GRF 寄存器堆，之前在P0已经设计过了。\n信号名 方向 位宽 Clk input 1 WE input 1 reset input 1 WD input 32 A1 input 5 A2 input 5 A3 input 5 RD1 output 32 RD2 output 32 IM 指令存储器，使用ROM实现，此前我因为审题不仔细导致这里卡了很久。要注意ROM的地址是以一个字为单位而不是字节，也就是说两个指令在mars中显示的地址是相隔4，用ROM表示其实只相隔1.\n信号名 方向 位宽 A input 12 D output 32 DM 数据存储器，用RAM实现。与指令存储器相比只多了一个写数据的功能。\n信号名 方向 位宽 Clk input 1 Wr input 1 A input 10 DI input 32 DO output 32 ALU 本文需要的指令只用得到四个运算：加、减、或和判断相等。其中等于可以用减来完成，减可以用补码来简化。\n信号名 方向 位宽 a input 32 b input 32 op input 2 c output 32 组建数据通路 取指令 PC与NPC实际上组成了一个MOORE型状态机，除这两个模块的所有部分都可以看成转移电路。\n图是gxp老师课件上的，实际电路NPC应该有几根线\n指令分解 纯粹体力劳动，把所有可能出现的指令部分全部分离出来。 ADDU \u0026amp; SUBU 最基础的指令，其他指令基本都是通过扩充这一部分的电路。 电路中rs、rt、rd分别给出读写指令，将运算的结果写入rd对应的寄存器中。 ORI 这一段稍微需要注意一下RTL。 由RTL知，我们要把立即数imm16作零扩展到32位后再参与或运算。同时，注意到这里需要输入GRF和ALU模块的信号与上面不同。rt作为了被写入的寄存器，同时进行运算的一个寄存器被换成了立即数。所以要在A3和B接口前使用MUX进行信号选择。每一次出现这类情况我们都用一个标签作为控制信号，最后使用打表方式一次性生成各指令的控制信号。 LW 首次出现了要对DM进行操作的指令。此时ALU的输出作为读DM的地址，DM的输出被写入对应寄存器中。此外，这里需要对立即数imm16进行的是有符号扩展，所以对EXT也要进行信号选择。 SW 写入而非读取，只需要加一个输入的数据信号和读/写控制信号即可。 BEQ 这一部分的逻辑主要是在NPC中完成的，此外只需要利用ALU的减法产生一个判断A、B是否相等的信号即可。 LUI 唯一老师上课没讲的指令，所以白嫖不了结构图了（悲伤）。 但实现非常简单，笔者将imm16拼接了一个16h'0的信号，然后直接连到GRF的WD端，配合MUX和控制信号即可。\n控制信号 为了使控制电路便于阅读和debug，我们使用或逻辑搭建电路，这样使得连线的目的非常明确。生成控制信号也许是最重要的一步，因为这一步很容易粗心。笔者就连错了一条。这里直接把我做的电路放上来。\n有人可能会问和逻辑呢？因为我用的是比较器所以省略掉了hhh。 跟上面的信号名不完全一样，仅供参考。\n测试数据 以下是我测试用过的数据，其中前一部分是pre给出的样例数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 .macro save(%dst) sw %dst,0($v0) lui $v1,0 ori $v1,$v1,4 add $v0,$v0,$v1 .end_macro ori $a0, $0, 123 ori $a1, $a0, 456 lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) sw $a3, 12($t0) sw $s0, 16($t0) sw $s1, 20($t0) sw $s2, 24($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) #以下为新写的 sub $v0,$v0,$v0 save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) sub $v0,$v0,$v0 lui $t0,0x7fff ori $t0,$t0,0xffff lui $t1,0xffff ori $t1,$t1,0xffff lui $t2,0 ori $t2,$t2,1 lui $t3,0x8000 ori $t3,$t3,0 add $s4,$t0,$t2 save($s4) add $s4,$t3,$t1 save($s4) sub $s4,$t0,$t1 save($s4) sub $s4,$t0,$t2 save($s4) lui $s0,0 beq $a1,$a1,equal ori $s0,$s0,0x1111 equal: ori $s0,$s0,1 save($s0) lui $s0,0 ori $s0,$s0,1 equal2: add $s0,$s0,$s0 beq $a1,$a1,equal2 save($s0) 除此之外，我还使用了大佬分享的评测机进行了测试和对拍。 以下是某一个随机生成的测试文件。 查看文档\n思考题 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。 答：发挥状态存储功能的模块：IFU、DM、GRF。发挥状态转移功能的模块：NPC、ALU、Control。 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。 答：合理，因为在本次的单周期CPU设计中，指令是只读的，所以使用只读的ROM进行存储。而DM需要频繁进行读写，所以使用RAM。GRF使用Register是标准设计，因为GRF本身就是寄存器堆，使用一堆寄存器搭建寄存器堆显然合理。此外，寄存器有高读写速度，适用于GRF的工作内容。 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。 答：没有。 事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？ 答：不需要。因为nop相当于sll $0,$0,0。即使在设置了sll指令时，因为这条指令并不改变寄存器值，也不会对运行产生影响。更别说我们这次的CPU压根没有实现sll指令。 阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。 答：总体来看相当弱。没有覆盖sub指令。对add指令测试了正正、正负、负负三种情况，较全面，但是没有针对极端值进行测试（虽然本CPU的add和sub不考虑溢出）。对于beq的测试也过于简单，没有测试offset和寄存器值为负和为0的情况。lw也没有针对$0寄存器作出检验。 ","date":"2024-10-23T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p3-logisim%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/pexels-jplenio-1105379_hu4455340264904558413.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p3-logisim%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/","title":"北航CO_P3-logisim搭建单周期CPU"},{"content":" 单周期CPU设计方案 概述 本次课下主要依靠P3的logisim进行翻译，不过我也对P3设计的一系列不合理之处进行了调整。我首先根据logisim电路图搭建各个模块，随后在mips.v文件中把各个模块合理地连接起来，最后添加controller模块产生控制信号。\n指令说明 本文实现的CPU在P3基础上添加了2条指令，即jal和jr。\nR型指令 add sub jr 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui J型指令 jal 空指令 nop 功能模块设计 IFU 将PC和IM合二为一。IM使用$readmehn语句读取code.txt文件里的指令。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 next_pc input 下一个指令地址 32 PC output 当前指令地址寄存器 32 instr output 当前指令 32 NPC 用组合逻辑计算出下一个指令的地址，通常是变为PC+4。根据控制信号不同会执行beq/jal/jr三种跳转。\n信号名 方向 描述 位宽 PC input 当前指令地址 32 offset input 分支偏移量 16 instr_26 input 指令中26位目标地址 26 ra_data input 从GRF返回的地址数据 32 zero input 分支条件标志 1 NPCOp input 下一地址选择操作码 3 next_pc output 计算后的下一指令地址 32 pc_add_4 output 当前地址加4的值 32 GRF 寄存器堆，同样是翻译即可。注意要display否则无法评测。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 RegWrite input 寄存器写入使能信号 1 RA1 input 读寄存器1地址 5 RA2 input 读寄存器2地址 5 WA input 写寄存器地址 5 WD input 写入数据 32 RD1 output 读寄存器1数据 32 RD2 output 读寄存器2数据 32 PC input 当前程序计数器地址 32 DM 数据存储器，朴实无华的读写功能。同样需要display。\n信号名 方向 描述 位宽 PC input 当前程序计数器地址 32 clk input 时钟信号 1 reset input 复位信号 1 MemWrite input 内存写入使能信号 1 WA input 写地址 32 WD input 写入数据 32 RD output 读取数据 32 ALU 本文需要的指令只需要四个运算：加、减、或。相等的判断用减法实现。\n信号名 方向 描述 位宽 ALUOp input ALU操作选择信号 3 A input ALU第一个操作数 32 B input ALU第二个操作数 32 zero output 结果是否为零标志 1 ALU_res output ALU运算结果 32 MUX 这个模块的设计和每个人自身的电路设计高度相关，我认为先建立mips.v顶层文件再构造更好。具体内容在下一部分讲解。\n信号名 方向 描述 位宽 rt input 源寄存器1地址 5 rd input 源寄存器2地址 5 WAOp input 写地址选择操作码 2 MemRD input 从内存读取的数据 32 offset input 偏移量 16 ALU_res input ALU运算结果 32 pc_add_4 input 当前PC加4的值 32 WDOp input 写数据选择操作码 2 RD2 input 第二个读寄存器的数据 32 Ext_imm16 input 扩展的16位立即数 32 BOp input B选择信号 1 B output 选择的第二个操作数 32 WD output 写入的数据 32 A3 output 写入的目标寄存器地址 5 组建数据通路 verilog组建数据通路的难度远大于logisim，因为不够直观，很容易漏接某些线。我认为比较不容易出错的设计方式如下：\n将除MUX外的所有模块放入mips.v文件中并接上所有的I/O端口。为防出错，所有的接口都用同名wire连接，可以先连好再定义这些wire型变量。 观察不同模块的接口，根据自己整理的表格/P3的电路图确定哪些端口之间是一对一连接的。使用assign语句把连接到对应端口的wire变量链接在一起。 对于需要用到多路选择器的端口，我们建立一个统一的MUX模块，这个模块负责处理所有需要进行信号选择的端口。我们将所有可能的输入信号和一会用Controller.v产生的选择信号全部作为MUX的输入，所有输出信号作为输出，内部使用条件判断语句为各个输出信号赋上对应的值。随后将其添加到mips.v中。 控制信号 建立一个新的Controller.v模块，因为CPU操作只跟指令有关，所以输入只需要opcode和funct。对于其内部结构，我喜欢先为每一条指令单独定义一个wire型变量，再以这些变量为条件去编写控制信号的生成逻辑。\n信号名 方向 描述 位宽 opcode input 指令操作码 6 funct input 功能码，用于区分操作类型 6 NPCOp output 下一地址选择操作码 3 RegWrite output 寄存器写使能信号 1 ALUOp output ALU操作码 3 MemWrite output 内存写使能信号 1 ExtOp output 立即数扩展操作选择信号 1 WAOp output 写地址选择操作码 2 WDOp output 写数据选择操作码 2 BOp output 第二操作数选择信号 1 ","date":"2024-10-23T00:00:00Z","image":"https://messmerr.github.io/pexels-jplenio-1105379.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p4-verilog%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/","title":"北航CO_P4-verilog搭建单周期CPU"},{"content":" 昨天晚上进行了计组P0的上机，他不是普通的上机，是国庆前夜的上机，是计组第一次影响分数的上机，这里除了6系牛马，没人配与他单挑。\n在去之前，我是十分焦虑的。这主要是北航CO的低容错所致：\n课程总计5.5学分，分为理论和实验两部分，其中实验部分占比超过2学分。 实验部分以课上为主，课上部分采取闯关制，只有通过前面的关卡才能继续挑战后面的关卡。例如你P5挂了，下一次上机别人做P6，你还是做P5，而且你并不是接着上一周的进度做，助教出了全新的三道题（快说谢谢助教），要是这次还不过，那下次继续。 根据往届的说法，前几次上机通过的要求都是AK,必须三道题全过，后面则会变成过两道即算通过。 上机难度通常不低，即使是那些公认的往届大佬都有不少挂过。 不过课程组也知道不能太为难学生，所以还是有一些保护措施，比如前几次上机不做卡关设置，没过也允许做后面的内容（我觉得这可能跟前几次上机不涉及迭代开发有关）。此外，据说再过几周会有一次整体的容错关，大家一起停一周，全过的同学无事可做，剩下的同学可以追一次进度。相当于提供了挂一次的容错。\n但是毫无疑问，即便如此上机依然是一个让人无比焦虑的事情，想想看，可能一个思路没转过来，就挂了一次上机，然后直接被大部队甩开，要是在同一关挂两次以上，那简直重开的心都有了。\n幸运的是，这次的P0是一个纯粹的奖励关。\n情况 我们寝室四个人都在开考后四十分钟至一个小时间AK交卷。同时，我交卷的时候仅我所在机房就有二十几个人排队在我前面等待签退，可见课程组发自内心的想让我们度过一个快乐的国庆。\n而且我们还发糖吃了，win。\n第一题 一道非常简单的组合逻辑的题目。要求计算一个四位四进制数的逆序数。\n在n个数码1，2，…，n的全排列j1j2…jn中，若一个较大的数码排在一个较小的数码的前面，则称它们构成逆序，这个排列的所有逆序的数量，称为这个排列的逆序数，记为τ(j1j2…jn)或π(j1j2…jn)。例如，在四个数码的排列3142中，3与1，3与2以及4与2都构成逆序，因此τ(3142)=3。逆序数为奇数的排列称为奇排列，逆序数为偶数的排列称为偶排列。\n这道题的思路连小学生看了上面的定义都知道，只需要从前往后依次比较六次，每次出现前大于后时加一即可。唯一可能需要注意的点就是比较器要设置为unsigned。\n第二题 一道非常简单的MOORE状态机的题目，只需要根据指令对两个寄存器进行简单的运算，00不变，01加1，10减1，11置0。有一个输入信号决定操作哪个寄存器。唯一需要注意的是操作一个寄存器时要保证另一个不变，这一点用使能端实现即可。\n第三题 一道简单的MOORE状态机的题目，需要输出由“0-9，a-f”构成的最长严格递增后缀子串的长度。\n例如，串abcdefg的后缀子串包括g,fg,efg,defg,cdefg,bcdefg,abcdefg。若一个后缀子串满足每一个数都比之前的数大，则称其为严格递增后缀子串。\n我的方法是使用两个寄存器，一个存储上一个数的值，另一个存储最长严格递增后缀子串的长度。状态更新非常简单，略而不表。\n","date":"2024-10-01T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Alogisim%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Alogisim%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/","title":"北航CO_P0课上——logisim的基础运用"},{"content":" FSM 这一题题干是检测是否输入的字符串是否符合给定的格式。\n具体格式是：先输入一到两个b，再输入两个a或c。\nIO In[1:0] I CLR I Z O 基本结构 Mealy状态机\n状态变量type 用寄存器表示\n状态0 如果输入b则状态为1，否则为0\n状态1 经过了Zebra同学的指点，我果断放弃了繁琐至极的原方法。 使用一个通用的计数器，输入b则判断计数器是否大于2，是则状态0且计数器置0，否则计数器增加，否则判断输入是否为a或c，都满足则计数器置1，状态2，否则状态0，同时计数器置0。 为什么不需要这个呢，因为这道题在连续输入b的时候无论几个都只需要保持状态1。\n如果输入b，保持状态1。 如果输入a或c，进入状态2。 否则变为状态0。\n状态2 如果输入b，进入状态1。 如果输入a或c，进入状态3，否则状态0。\n状态3 如果输入b，保持状态1。 如果输入a或c，进入状态0。\nPS：状态3其实是多余的，但是两位的寄存器放四个状态比较舒服\n复位 同步复位，使用MUX。\n子模块设置 状态转移模块 输入：type寄存器的输出和in 输出：type寄存器的输入\n输出模块 与常规Mealy状态机一样，本题是状态为2且输入为a或c即输出1。\n","date":"2024-09-26T19:32:28+08:00","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Bfsm/matt-le-SJSpo9hQf7s-unsplash_hu4699868770670889127.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Bfsm/","title":"北航CO_P0课下——FSM"},{"content":" 花了好几个小时总算把个人博客搭好了。至于为什么要搭这个博客，只能说人终究是从众的生物，当你看到那么多6系大佬都有自己的博客，难免会想着自己搭一个。\n此外，有一说一昨天的CO上机真是一场灾难\n考试机制 每周的考试让人回忆起高中的峥嵘岁月，CO作为北航精品课程，处处都体现出了不同于其他课程的威压：\n在新北地下机房上机，禁止携带电子设备，校园卡验明真身 只能使用学校机房电脑（这意味着不能使用任何电子资料） 机房电脑手感极度糟糕1 电脑自带程序相当有限，我的vscode上配置了基础的C环境，有verilog插件和Markdown插件，然而听有些人说他们的vscode连verilog插件都没有，语法不熟悉就直接寄 这次的考试机制是总时长三小时，其中前两个小时纯自己做，最后一个小时发出提示文件，还可以向助教提问，三道题都AC之后可以点击交卷，随后助教就会过来提几个问题（然而我因为交卷太晚助教让我直接走），结束之后就可以离开了。令人惊讶的是这次上机只要在三个小时内AK，课程平台上就一律算通过，于是像我这种三道题全是最后一小时AC的大混子也有个通过标。\n第一题 第一题是一道logisim的MOORE状态机的题目，要求根据输入的不同切换数列的递推方式，这一构造没有什么难度，只要用一个额外的寄存器存储前n项和的值即可。然而这一题最大的难点在于——同步复位。\n属于是COpre魅力时刻了，因为COpre上根本没有涉及到同步复位的设计方法，我们之前做的题全部都是异步复位。于是我的设计过程是这样的：\n首先使用异步复位，即直接把reset信号练到寄存器的复位端，四个测试点过两个。 重新审题，发现需要使用同步复位，经过短暂思考，决定把clk信号和reset信号用与门连接在一起，合成同步的reset信号，然后接到寄存器的复位端。四个测试点过三个。 然后我就卡住了（允悲）。 所以问题出在哪呢？原来是因为使用与门会导致毛刺的出现，因为延时的问题，导致clk上升沿到达寄存器和clk和reset的与到达寄存器的时间有了微妙的差异，于是就会出现先正常更新一次数据再突然复位的错误现象。\n那么这个问题如何解决呢？答案是直接放弃寄存器的复位端。直接使用MUX，以reset为选择信号，reset为0时正常输入，为1时则输入初始值。这样就保证复位一定是在clk上升沿进行了。\n先写到这里，这是第一篇博客，先push一下看看显示正常不。 OK，没问题，但是我要写P0课下了，暂时先到这里 好的，这一等就是一个星期，现在是10月1号下午五点，我正在高铁上。昨天已经把P0课上考完了。\n第二题 第二题是verilog的一道非常基础的题目。几乎只是对基础语法的一个考查。整个算法只涉及一个简单的循环，如果使用vscode插件的话基础语法的正确性也有保障。然而我依然耻辱地在这一题卡了四十分钟，因为我把阻塞赋值和非阻塞赋值搞混了。\n这确实非常不应该，因为阻塞赋值和非阻塞赋值也是COpre重点描述的内容，然而我并没有认真看（允悲）。因此我对这两东西的印象就停留在always里面用非阻塞赋值，外面的就用阻塞赋值。然而事实并非如此。事实上直到现在我也没完全弄清楚（这周实在是太摆烂了），不过我的印象也升级为了组合逻辑一定用阻塞赋值（包括always @(*)内的语句，时序逻辑才用非阻塞赋值）。\n第三题 第三题与第二题定位类似，是一道极为基础的MIPS题目，代码只涉及简单的循环，条件判断。考虑到mars的help是三款软件中最简单易懂的（写语句的时候直接把意思都标出来，他真的我哭死），只要COpre学会了就不会有问题。\n总结 总而言之这次CO上机确实是非常简单，然而正是因为它太简单才显得我在考场被卡住的样子更加狼狈。不过事后我发现周围的人情况都跟我类似，大概这是第一次上机的普遍现象吧。\n黏糊糊，且有奇妙拖拽感的鼠标，不知为何看起来很不清晰的显示屏，敲起来完全不跟手的键盘……\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-24T12:10:01+08:00","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco%E4%B8%8A%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco%E4%B8%8A%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"北航CO上机初体验"}]