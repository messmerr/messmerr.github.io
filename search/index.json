[{"content":" OS-SWAP 实验报告 前言 个人感觉SWAP相比Shell来说要不友好一些，因为很难有循序渐进的正反馈，做题的大部分时间都在对着各种报错痛苦地干瞪眼。本次任务我分了两段时间做，一次是考军理之前，花了两天整的时间企图给他速通掉，结果最后被一个顽固的bug击败，选择先复习。然后是24号考完马原之后又做了一天半，最后才完成。\n题目要求基于自己的lab6进行迭代，实现一套页面置换（SWAP）机制。该实现采用Linux风格的LRU（Least Recently Used）算法，通过维护active_list和inactive_list两个双向链表来管理物理页面的访问频率，并在物理内存不足时将页面换出到磁盘，在访问时自动换入。\n题目分解 工作内容 LRU算法实现：正确维护active_list和inactive_list双向链表，跟踪页面访问模式 SWAP操作：为内核创建访问磁盘的接口，实现swap_out和swap_in操作，管理磁盘存储 COW兼容性：确保SWAP机制与Copy-On-Write机制正确协作 性能优化：避免频繁的TLB刷新，优化磁盘访问 一些注意事项 MIPS R4K没有硬件访问位，需要通过软件TLB重填模拟。记得考虑奇偶页的问题。 页表项需要同时支持COW、SWAP等多种状态 注意换出页面的状态保存和恢复 确保系统稳定性，避免页表等关键页面被换出 具体实现 数据结构扩展 为了支持功能，我对核心数据结构进行了扩展。\n首先，扩展了Page结构体。这部分基本按照题目来就好，例如新增页面标志位（pp_flags），其中我使用的有PG_REFERENCED用于标记页面近期是否被访问，PG_PINNED用于“钉住”关键页面防止被换出，以及后期做性能优化的时候我临时追加了PG_ACTIVE和PG_INACTIVE用于标识页面当前所在的LRU链表，避免每次都遍历。\n同时，为了在换出页面时能找到所有指向它的页表项（PTE），每个Page结构体维护一个Pte_list链表，链表中的每个节点PteNode都包含一个指向PTE的指针、该PTE对应的虚拟地址以及地址空间ID（ASID）。这样，当一个物理页需要被换出时，可以遍历这个链表，修改所有相关的PTE。\n此外，当一个页面被换出到磁盘后，其在Page结构体中保存的状态（如引用计数pp_ref和页表项链表pp_pte_list）需要被保留。为此，我也是用了题目推荐的状态管理结构PageState，并创建了一个全局数组page_state_set。该数组以磁盘块号为索引，用于存放换出页面的PageState信息，确保页面换入时能够正确恢复状态。\nLRU算法实现 LRU算法的核心在于追踪页面访问模式和定期老化页面。\n页面访问追踪通过page_touch函数实现。当一个页面被访问时，该函数会被调用。它首先检查页面是否被钉住，如果是则不参与LRU管理。否则，它会设置页面的PG_REFERENCED标志位。如果页面原先在inactive_list中，page_touch会将其移动到active_list的末尾，表示它最近被频繁使用。如果页面是新分配的，则会被加入inactive_list的末尾。\n页面老化机制由shrink_active_list函数负责，该函数会定期执行（例如在调度器中）。它遍历active_list中的所有页面：\n如果页面的PG_REFERENCED标志位被设置，说明它在上一轮老化周期中被访问过。此时，函数会清除该标志位，给予它“第二次机会”，让它留在active_list中。 如果标志位未被设置，则说明该页面近期“不活跃”，函数会将其从active_list移动到inactive_list的头部，使其成为优先被换出的候选者。 SWAP磁盘管理 使用磁盘的次IDE控制器作为SWAP分区，以避免与主文件系统冲突。访存操作对着lab5里的内容模仿即可。\n磁盘空间分配采用位图（bitmap）来管理。为了提高分配效率，我引入了一个next_free_hint变量作为优化。分配函数swap_block_alloc会从next_free_hint指示的位置开始搜索空闲块，而不是每次都从头开始。找到空闲块后，更新next_free_hint，这大大减少了平均搜索时间。\n页面换出实现 页面换出是内存紧张时的核心操作，由置换算法和具体的换出逻辑组成。\n置换算法（algo_swap）负责挑选一个“受害者”页面。它的策略如下：\n优先在inactive_list中寻找。 遍历inactive_list，如果一个页面未被钉住（这也算是重复检查了）且其PG_REFERENCED标志位为0，则它就是理想的受害者，算法直接返回该页面。 如果页面的PG_REFERENCED标志位为1，则清除该标志位，给予其最后一次机会，然后继续查找下一个。 如果遍历完inactive_list仍未找到合适的页面（或列表为空），则调用shrink_active_list将active_list中的不活跃页面老化到inactive_list中，然后重试查找。 换出操作（swap_out）是具体的执行者：\n调用algo_swap获取一个受害者页面。 调用swap_block_alloc在磁盘上申请一个空闲块。 将受害者页面的状态（引用计数、PTE链表）保存到与磁盘块号对应的page_state_set条目中。 通过IDE接口，将受害者页面的物理内存内容写入到分配好的磁盘块中。 遍历该页面的PTE链表，对每一个PTE进行修改：将其有效位（PTE_V）清零，设置一个自定义的PTE_SWAP标志位，并将物理地址部分替换为磁盘块号。同时，精确地使该PTE对应的TLB条目失效。 最后，清空受害者Page结构体的状态，使其成为一个干净的空闲页，可以被系统重新分配。 页面换入实现 当程序访问一个已被换出的页面时，会触发缺页异常，最终调用swap_in函数。\nswap_in的逻辑与swap_out相反：\n从触发异常的PTE中，解析出PTE_SWAP标志位和存储在地址部分的磁盘块号。 调用page_alloc分配一个新的物理页面。如果此时内存不足，page_alloc内部可能会递归地触发一次swap_out。 通过IDE接口，从磁盘的指定块号中将页面内容读入新分配的物理页。 从page_state_set数组中取出该页面之前保存的状态，并恢复到新的Page结构体中（包括引用计数和PTE链表）。 遍历恢复的PTE链表，将每个PTE重新指向新的物理页地址，并设置PTE_V、清除PTE_SWAP标志。 释放磁盘上的SWAP块，并清理page_state_set中对应的条目。 最后，调用page_touch将这个新换入的页面加入LRU管理体系。 TLB重填优化 为了将SWAP机制集成，我修改了TLB重填处理函数_do_tlb_refill。当发生TLB未命中时，内核会查找对应的PTE。\n如果PTE中设置了PTE_SWAP标志，处理函数会立即调用swap_in，将页面从磁盘换回内存，并自动处理PTE的更新。 在页面被确认在内存中后（无论是原本就在还是刚刚换入），调用page_touch来更新其在LRU链表中的位置。 考虑MIPS处理器的奇偶页TLB项设计，确保成对的PTE被正确加载。 这种设计实现了按需换入，并且将LRU状态更新与页面访问紧密结合。\nCOW机制兼容性 为了让SWAP与写时复制（COW）协同工作，我调整了fork中的页面复制逻辑，并在SWAP相关代码考虑COW的存在。例如，fork操作在复制一个父进程的地址空间时：\n如果一个页表项指向的页面是只读、COW页面，或者是已换出的页面（即PTE带有PTE_SWAP标志），那么子进程只复制这个页表项，而不分配新的物理页面。 对于已换出的页面，父子进程将共享同一个指向磁盘块的PTE。当其中任何一个进程首次访问该页面时，才会触发swap_in，并将页面加载到内存。此时，再结合COW逻辑，将其设置为只读。 性能优化要点 我最后的修复是解决TLE。我在本地发现三个样例都过之后兴冲冲的去交，然后惨遭重拳，评测结果全空。\n经助教认证，这是典型的TLE症状。我去测了一下，我的项目此时跑完fork样例要花三分多，确实是太慢了。于是我开始做下面的优化。\n1. TLB刷新优化 移除schedule中的全局TLB刷新 仅在页面状态变化时进行精确刷新 2. 磁盘访问优化 使用hint机制加速空闲块分配 3. 内存管理优化 使用页面标志位快速判断状态 优化链表操作减少遍历开销 大模型使用 不建议在搭建过程中依赖大模型。大模型是强大的工具，但是前提是自己得看过并能看懂他的代码，不然省下的精力会在debug阶段通通还回去。时刻保证自己对架构有掌控力是很重要的。\n但是gemini还是很适合提出建议和找bug的，除了直接扔文件以外，让他帮着用命令行体验也很不错，成功帮我这个从没用过gdb的人靠看栈找到了一个关键bug。\n感想 随着实验报告的完成，操作系统这门课程也正式告一段落。从lab0 extra的挫败到后面的习以为常，再到被SWAP折磨的这几个夜晚，这一切都要成为过往了。\n操作系统的任务全部完成之后，大二的学习内容就基本全部结束。马上就要成为一年前觉得遥不可及的大三老登了，时间过得真快。\n","date":"2025-06-26T00:00:00Z","image":"https://messmerr.github.io/p/os-swap-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/domenico-loia-hGV2TfOh0ns-unsplash_hu4086910433182145202.jpg","permalink":"https://messmerr.github.io/p/os-swap-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","title":"OS-SWAP 实验报告"},{"content":" OS-lab0 实验报告 思考题 Thinking-0.1 Q：执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。\nA：这两个 status 不一样，因为第一次 README.txt 是新文件，没有被暂存，因此显示Untracked files，但当最后我们修改之前已经被提交的 README.txt，git 检测到的是修改了已有文件，故显示Changes not staged for commit。\nUntracked.txt：\n1 2 3 4 5 6 7 8 9 10 On branch main No commits yet Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) README.txt Untracked.txt nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) Modified.txt：\n1 2 3 4 5 6 7 8 9 10 11 On branch main Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: README.txt Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) Modified.txt Stage.txt Untracked.txt Thinking-0.2 Q： 仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？\nA：分别是git add，git add和git commit，前两个的区别在于添加的是未跟踪文件还是已修改文件。\nThinking-0.3 Q：思考下列问题： 1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ 2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？ 3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下 将其移出暂存区？\nA：\n1 git restore print.c 1 2 git restore --staged print.c git restore print.c 1 git restore --staged hello.txt Thinking-0.4 Q：按照指导书进行若干操作，通过多次git log观察其变化。\nA：四次git log输出分别如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:11:32 2025 +0800 3 commit a41d443ed1c531f6a4ae09e37ab25a0b0c1ad229 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:11:17 2025 +0800 2 commit 0dcbd1a4f693813cfb9212b974a6d161a2696de1 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:10:45 2025 +0800 1 commit 439b930fdd6bb1cebebe48bd91237c44cdfe4c15 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 10:46:12 2025 +0800 23371301 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:11:17 2025 +0800 2 commit 0dcbd1a4f693813cfb9212b974a6d161a2696de1 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:10:45 2025 +0800 1 commit 439b930fdd6bb1cebebe48bd91237c44cdfe4c15 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 10:46:12 2025 +0800 23371301 1 2 3 4 5 6 7 8 9 10 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:10:45 2025 +0800 1 commit 439b930fdd6bb1cebebe48bd91237c44cdfe4c15 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 10:46:12 2025 +0800 23371301 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 commit 3bf0d798caadb39ec68cb203c6a83865b21d19be (HEAD -\u0026gt; main) Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:11:32 2025 +0800 3 commit a41d443ed1c531f6a4ae09e37ab25a0b0c1ad229 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:11:17 2025 +0800 2 commit 0dcbd1a4f693813cfb9212b974a6d161a2696de1 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 11:10:45 2025 +0800 1 commit 439b930fdd6bb1cebebe48bd91237c44cdfe4c15 Author: Xiao Yihan \u0026lt;23371301@buaa.edu.cn\u0026gt; Date: Fri Mar 14 10:46:12 2025 +0800 23371301 以上结果展现了在git中回退版本的各种操作。\nThinking-0.5 Q：执行如下命令, 并查看结果：\n1 2 3 4 echo first echo second \u0026gt; output.txt echo third \u0026gt; output.txt echo forth \u0026gt;\u0026gt; output.txt A：结果如下（对于输出到文件的指令展示文件内容）：\n1 first 1 second 1 third 1 2 third forth 这主要体现了重定向中覆盖和追加的不同效果。\nThinking-0.6 Q：使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test）， 将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将 运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结 果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问题: echo echo Shell Start 与 echo echo Shell Start 效果是否有区别; echo echo $c\u0026gt;file1 与 echo echo $c\u0026gt;file1 效果是否有区别.\nA： command 文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 echo \u0026#39;echo Shell Start...\u0026#39; echo \u0026#39;echo set a = 1\u0026#39; echo \u0026#39;a=1\u0026#39; echo \u0026#39;echo set b = 2\u0026#39; echo \u0026#39;b=2\u0026#39; echo \u0026#39;echo set c = a+b\u0026#39; echo \u0026#39;c=$[$a+$b]\u0026#39; echo \u0026#39;echo c = $c\u0026#39; echo \u0026#39;echo save c to ./file1\u0026#39; echo \u0026#39;echo $c\u0026gt;file1\u0026#39; echo \u0026#39;echo save b to ./file2\u0026#39; echo \u0026#39;echo $b\u0026gt;file2\u0026#39; echo \u0026#39;echo save a to ./file3\u0026#39; echo \u0026#39;echo $a\u0026gt;file3\u0026#39; echo \u0026#39;echo save file1 file2 file3 to file4\u0026#39; echo \u0026#39;cat file1\u0026gt;\u0026gt;file4\u0026#39; echo \u0026#39;cat file2\u0026gt;\u0026gt;file4\u0026#39; echo \u0026#39;cat file3\u0026gt;\u0026gt;file4\u0026#39; echo \u0026#39;echo save file4 to ./result\u0026#39; echo \u0026#39;cat file4\u0026gt;\u0026gt;result\u0026#39; result 文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Shell Start... set a = 1 set b = 2 set c = a+b c = 3 save c to ./file1 save b to ./file2 save a to ./file3 save file1 file2 file3 to file4 save file4 to ./result cat file1 cat file2 cat file3 3 2 1 在实现中，echo echo Shell Start 与 echo echo Shell Start没有区别，因为后面的内容会被视为普通字符串，无论加不加引号都不会触发解析。但是 echo echo $c\u0026gt;file1 与 echo echo $c\u0026gt;file1 有区别，因为其中有 $ 的存在，如果不用\u0026rsquo;\u0026lsquo;包裹，就会对其做变量解析。\n难点分析 本次实验主要考察对实验环境、Linux 操作系统的了解、以及git 等重要工具的使用。我认为这次作业的主要难点有三个方面：git 的使用、Makefile 的设计以及 shell 脚本的撰写。\n实验体会 在本次 lab0 实验中，我初步掌握了 Linux 的常用命令，深入接触了 Git、Makefile 和 Shell 脚本等开发工具。最初接触这些新工具时，我感到有些困惑和不适应，例如Makefile 的嵌套等，而攻克这些问题需要我再次查阅指导书或向互联网寻求帮助。\nShell 脚本部分可能是我钻研最多的环节。文本处理命令如 sed、awk 初看起来很难，实际上也不简单。尤其是理解单双引号和$带来的行为差异和一些特殊参数的用法，这些细节在学习过程中很难吃透，却容易在上机时导致意想不到的问题。\n总的来说，这次实验让我认识到，掌握这些基础工具不仅能提高编程效率，更是培养系统思维和工程化思想的重要途径。虽然学习曲线有些陡峭，但这些技能的价值会在今后的项目开发中不断体现出来。\n","date":"2025-03-10T00:00:00Z","image":"https://messmerr.github.io/p/os-lab0-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://messmerr.github.io/p/os-lab0-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","title":"OS-lab0 实验报告"},{"content":" MIPS微系统设计方案 概述 刚刚拿到实验教程的时候真的感到无从下手，不过在学长博客和gxpPPT的指引下还是解决了。这里贴出我用到的三个博客以示感谢。\n北航CO 2024 P7课下部分个人理解分享 | Lazyfish \u0026amp; chilly_river [BUAA-CO-Lab] P7 MIPS 微体系 | ROIFE BLOG 「BUAA-CO」P7_MIPS微系统（异常中断） | Hyggge\u0026rsquo;s Blog 有一说一我觉得助教是刻意把教程弄成这样的。因为教程里都写了P7注重考验同学们的自主设计，并且在设计上给了同学们相当大的自由。不过我觉得还是改了为好。\n搭建思路 P7要做的事情有些琐碎，因此选择一个良好的操作顺序非常重要，以下是我的工作流程。\n搭建CP0，建议放M级。 产生异常，设计出ExcCode信号并随流水线传递到M级，注意课程组给出的条件，注意一条指令多个异常和多条指令同时异常的情况。 根据CP0的需求爆改流水线，包括但不限于 将CP0需要的已知信号统统流水传递过来，原本没有的（如表示当前指令是否为延迟槽指令的BDIn）就生成出来。 在Controller模块中加入四条新指令即mfc0,mtc0,eret,syscall。选择合适的控制信号，个人建议syscall和eret单独拉出来。 在CPU中以合适的方法建立四条新指令的数据通路。做这里的时候加吐我了，因为之前没有使用宏定义，导致很多之前不需要传递的信号都要传递。 处理冒险，mfc0转发直接用原有的数据通路。阻塞则只需要加一条eret相关阻塞，处理mtc0对EPC进行写入的问题， 通过修改流水级寄存器和NPC完成异常中断的跳转和返回过程。这里我们把CP0产生的异常中断信号req传给这些模块，将流水级寄存器除了PC以外的内容置0，PC置为32'h4180，并让NPC跳转到32'h4180处，注意对实验教程中提到的对乘除模块的处理。返回则是当eret产生时，NPC跳回EPC同时清空延迟槽（操作想必大家都知道，注意阻塞的情况）。 调整模块结构，规范化CPU的输入输出端口，并建立新的mips顶层模块，将CPU和课程组给的Timer放进去。 设计Bridge模块，这个模块在P7的作用仅仅是判断当前读写的是哪个外设并处理对应的信号，实现相当简单。 把线都连好，大功告成。 功能模块设计 挑出比较重要的新增模块。\nCP0 值得一提的是内部，许多学长是直接定义了IM,EXL,IE等寄存器，在写入时则用拼接的方式这是合理的，因为SR,Cause中的绝大部分位数没有用。当然，还可以使用在模块内用宏定义，具体怎么实现看个人喜好。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 en input 启用信号，控制CP0模块的操作 1 CP0Add input 控制寄存器选择信号，指定访问的寄存器地址（5位） 5 CP0In input 往CP0寄存器写入的数据 32 VPC input 异常发生时的程序计数器值 32 BDIn input 异常时的返回地址标志 1 ExcCodeIn input 异常代码 5 HWInt input 硬件中断请求信号（6位） 6 EXLClr input 清除异常级别标志（用于清除SR[1]） 1 EPCOut output 异常程序计数器（EPC）输出 32 CP0Out output 读取的CP0寄存器值，根据CP0Add选择 32 Req output 异常或中断请求信号 1 Bridge 连个线，没啥可说的。\n信号名 方向 描述 位宽 Addr input 地址输入，决定访问的外设区域 32 byteen input 字节使能信号，用于指示操作的字节 4 DM_RD input 数据存储区读取数据 32 T0_RD input 定时器0读取数据 32 T1_RD input 定时器1读取数据 32 RD output 输出数据，根据地址选择不同外设的读取数据 32 DM_WE output 数据存储区写使能信号，根据地址选择是否写入数据存储区 4 T0_WE output 定时器0写使能信号 1 T1_WE output 定时器1写使能信号 1 int_WE output 中断控制寄存器写使能信号 4 关于BUG P7真的很容易写出各种各样的BUG，所以自行测试的时候就很考验数据点编写的能力（虽然我大部分都是找别人要的）。但如果要自己编写测试点，建议先把每种类型的异常全部构造出对应的点，先检验有没有漏判的问题。随后认真观察波形图，分析一下进入异常处理程序后各寄存器的情况，以及是怎么跳转回去的，跳转回去各寄存器的情况又如何。理解好异常中断的处理过程对于找bug好处很大。\n此外，评测机真的是好东西，cokiller帮我解决了大部分BUG，虽然最后还是漏了就是了。还有就是学长博客，以及多跟同学交流，很多BUG是共通的，例如空泡的问题。\n测试方案 之前P3的时候想着P4再搓评测机，到后面每天疲于奔命也没有自己搓了。 于是我就自己写了一点巨弱的测试点，然后又找大佬要了一堆强力测试点。\n思考题 请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？ 答：鼠标和键盘的输入信号通过硬件接口（如PS/2、USB或蓝牙）传输到计算机。当按下键盘的某个按键时，它会发送一个扫描码；鼠标则发送位置和点击信号。这些信号通过设备驱动程序转化为操作系统可以理解的格式，操作系统通过中断或轮询方式接收这些信号，并将其传递给相应的应用程序。最终，CPU根据这些输入信号作出响应，例如显示字符或移动鼠标指针。整个过程依赖硬件接口、驱动程序、操作系统和中断机制的协作。\n请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法） 答：因为这样可以简化设计，增加系统的稳定性和可靠性。可以提供，但是可能会出现增加安全性问题，因为用户可能会选择不够安全的入口。此外，不同程序采用不同的入口可能导致冲突，出现故障时也不容易排查Bug.\n为何与外设通信需要 Bridge？ 答：因为在我们的设计中，CPU不需要知道外设的具体信息，只需要对程序指定的地址进行访问。这样符合高内聚低耦合的思想。\n请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。 答：区别是enable是否是自动赋值。 倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？ 答：那么EPC会变成0，这样跳回时会引发错误。所以应该保留PC信息和本条指令是否是延迟槽的信息。\n为什么 jalr 指令为什么不能写成 jalr $31, $31？ 答：因为我们处理延迟槽指令发生异常时EPC会指向跳转指令，因此从异常处理程序返回后跳转指令实际上总共被执行了两次，而jalr具有累加效应，第二次执行的jalr和第一次是不一样的，所以会出错。\n","date":"2024-11-28T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F/20241128135158_hu17112569606908118098.png","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p7-mips%E5%BE%AE%E7%B3%BB%E7%BB%9F/","title":"北航CO_P7-MIPS微系统"},{"content":" 流水线CPU设计方案 概述 没想到P6意料之外的很轻松，只要加指令就行了，而这一届课程组给的指令巨好写，只有一个乘除模块需要花点时间。\n指令说明 本次在P5包含的指令基础上增加了十八条指令（这也太少了，感动）。\nR型计算型指令 and or slt sltu 改一改ALU和控制信号就解决了，巨方便。 I型计算型指令 andi addi 同上。 B型指令 bne 跳转可以出不知道多少复杂的题，课程组却选择了最简单的一个。只要加一个控制信号就行了。 访存指令 lh lb sh sb 本来这个应该算是个需要思考的点的，结果课程组把IM，DM分出来之后只要确定字节使能信号和输入的数据就可以了。 乘除指令 mult multu div divu mfhi mflo mthi mtlo 最需要动脑子的一集，不过看了教程也不难。 功能模块设计 绝大部分地方跟P5一样，所以只选新增的展示。\nMDU（乘除模块） 这是一个时序逻辑模块，根据课程组要求，为了模拟乘除法执行时间长的现象，我们要在五（十）个周期后才能完成操作，不过要注意的是，因为E级流水线寄存器不会等着乘除模块（甚至阻塞时也不会，因为E级是清空），所以必须在指令刚到（即start == 1时）的时候就把需要用到输入的运算全部做完。我的处理是在内部设置HI_tmp和LO_tmp两个寄存器，计算时直接把值存到这两个寄存器里，计数器数到0时再移到正式的HI和LO寄存器。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 start input 开始信号，触发运算 1 MDUOp input 乘除单元操作码 4 A input 第一个操作数 32 B input 第二个操作数 32 out output 输出结果，根据操作码选择的寄存器值 32 busy output 繁忙信号，指示MDU是否正在工作 1 DataExt 为lh和lb量身定做的模块，\n信号名 方向 描述 位宽 A input 访存地址最后两位，用于选择字节或半字位置 2 Din input 输入数据 32 Op input 数据扩展操作码 3 Dout output 输出扩展后的数据 32 根据Op决定是哪个指令，再根据A决定读到的数据是什么。\n搭建转发数据通路 为了方便，我直接在E级把乘除模块的输出和ALU的输出用选择器拼在了一起，所以二者完全共享相同的数据通路，不需要考虑任何转发的问题。\n阻塞信号的生成思路 因为乘除法的执行必须通过mfhi和mflo才能影响其他指令，同时课程组保证乘除后一定会接这两个指令，所以我们可以简单粗暴的把乘除法相关的阻塞信号写成：\n1 2 3 assign stall_md = ((start || busy) \u0026amp;\u0026amp; (D_MDUOp \u0026gt; 4\u0026#39;h0)); // D_MDUOp为0表示其他指令，1-8分别对应八条乘除相关指令。 // 只有当乘除法开始进行或正在进行且D级指令也是乘除相关时阻塞 然后再把这个信号和其他阻塞信号或起来就行了。\n测试方案 依然是手写了若干测试代码，把新增的指令都测到了，其中最上面那一块是我测出来的bug，mtlo错误地把输入口B而非A存入了LO寄存器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ori $21,$0,0xabcd mtlo $21 nop nop mfhi $3 andi $8,$19,0x2f4 mflo $1 lui $s0,0xf19a ori $s0,$s0,0x0233 lui $s1,0x2da3 ori $s1,$s1,0x4d14 mult $s0,$s1 mflo $s0 mfhi $s0 mthi $0 mfhi $s0 multu $s0,$s1 mflo $s0 mfhi $s0 mtlo $0 mflo $s0 div $s0,$s1 mflo $s0 mfhi $s0 mthi $0 mfhi $s0 divu $s0,$s1 mflo $s0 mfhi $s0 label: ori $t0,$0,1 label2: ori $t1,$0,2 beq $t0,$t1,label2 bne $t0,$t0,label3 bne $t0,$t1,label nop label3: ori $s0,0x4215 lui $s1,0x8000 ori $s1,0x9315 add $s2,$s1,$s0 sub $s2,$s1,$s0 and $s2,$s1,$s0 or $s2,$s1,$s0 slt $s2,$s1,$s0 sltu $s2,$s1,$s0 lui $s0,0xabcd ori $s0,0xefff sb $s0,0($0) sb $s0,5($0) sb $s0,10($0) sb $s0,15($0) sh $s0,0($0) sh $s0,2($0) sw $s0,0($0) lb $s1,0($0) lb $s1,1($0) lb $s1,2($0) lb $s1,3($0) lh $s1,0($0) lh $s1,2($0) lw $s1,0($0) 思考题 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？ 答：乘除法的时间消耗远大于加减等运算，为了保证性能，我们选择将其独立出来，用多个时钟周期计算。独立的HI、LO寄存器作为乘除模块与其他部分的桥梁，符合高内聚低耦合的设计原理，如果不这样做，乘除模块的多执行周期很可能导致大量冒险的出现。 真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。 答：将乘除法分成多个步骤，用多周期去实现，或者分散到流水线各级逐步实现。 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？ 答：如果当前Start或Busy为1同时D级当前指令为乘除指令则阻塞。 请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑） 答：直接用信号的形式展现出了当前操作作用的内存部分，一目了然。同时抽象出了不同访存指令的根本不同，形式统一。 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？ 答：不是，事实上我们只是把一字节从读写的字中拆出来。当内存访问局部性差，数据小且存放位置离散时，字节读写效率可能更高。 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？ 答：对于指令太多的问题，我使用了分类的方法，将功能和执行过程相近的指令放在一起，使得生成控制信号的时候一目了然。此外，我用多路选择器将不同的写入数据合在一起，共用转发数据通路，大幅减少了处理冒险时的复杂性。 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？ 答：mfhi和mflo与读取寄存器的指令产生的数据冒险，使用转发解决。还有乘除相关指令彼此之间的数据冒险，用阻塞解决。测试样例如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ori $21,$0,0xabcd mtlo $21 nop nop mfhi $3 andi $8,$19,0x2f4 mflo $1 lui $s0,0xf19a ori $s0,$s0,0x0233 lui $s1,0x2da3 ori $s1,$s1,0x4d14 mult $s0,$s1 mflo $s0 mfhi $s0 mthi $0 mfhi $s0 multu $s0,$s1 mflo $s0 mfhi $s0 mtlo $0 mflo $s0 div $s0,$s1 mflo $s0 mfhi $s0 mthi $0 mfhi $s0 divu $s0,$s1 mflo $s0 mfhi $s0 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。 答：首先保证所有指令都在测试范围中，随后要重点考虑边界条件和不同指令之间可能冲突的地方。例如对于乘除指令要测试multu和divu对于负数的运算，还有后面接mf指令的阻塞情况。 ","date":"2024-11-15T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p6-verilog%E6%90%AD%E5%BB%BA%E4%B8%89%E5%8D%81%E6%9D%A1%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu/david-becker-F8c-KXMxnzk-unsplash_hu116060358458621242.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p6-verilog%E6%90%AD%E5%BB%BA%E4%B8%89%E5%8D%81%E6%9D%A1%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu/","title":"北航CO_P6-verilog搭建三十条指令的五级流水线CPU"},{"content":" 流水线CPU设计方案 概述 本次课下我根据P4的代码进行了大规模重构，加入了五级流水线寄存器和转发的控制通路，最后针对转发和阻塞编写了冒险处理模块。\n指令说明 本文实现的CPU包含的指令与P4相同。\nR型指令 add sub jr 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui J型指令 jal 空指令 nop 功能模块设计（含流水线寄存器） 以下功能模块排列按照所在阶段从前往后排布。\nIFU 相对P4，加入了使能信号和PC+8的值，分别是为了应对阻塞时冻结PC和跳转延迟槽的问题。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 en input 使能信号 1 next_pc input 下一个指令地址 32 PC output 当前指令地址寄存器 32 instr output 当前指令 32 PC_8 output 当前指令地址 + 8 的值 32 IF_ID 第一个流水线寄存器。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 en input 使能信号 1 F_instr input 取指阶段的当前指令 32 F_PC input 取指阶段的当前指令地址寄存器 32 F_PC8 input 取指阶段的当前指令地址 + 8 32 D_instr output 译码阶段的当前指令 32 D_PC output 译码阶段的当前指令地址寄存器 32 D_PC8 output 译码阶段的当前指令地址 + 8 32 Controller 加入了新信号Tuse和Tnew的产生逻辑，这两个信号将用于判断阻塞，后面将会详细分析。\n信号名 方向 描述 位宽 opcode input 操作码，决定操作类型 6 funct input 功能码，辅助操作码决定功能 6 NPCOp output 下一个PC的操作码选择 3 RegWrite output 寄存器写使能信号 1 ALUOp output ALU操作选择信号 3 MemWrite output 内存写使能信号 1 ExtOp output 符号扩展操作选择 1 WAOp output 写地址选择信号 2 WDOp output 写数据选择信号 2 BOp output 分支操作信号 1 Tuse output 使用时间信号 2 Tnew output 新数据时间信号 2 NPC NPC是个特殊的模块，因为他不严格位于某个特定的阶段，他的输入既有F阶段的PC，也有D阶段的PC，所以编写具体逻辑的时候需要考虑，例如b和j型指令在跳转时要用到的是PC+8而非PC+4。\n信号名 方向 描述 位宽 F_PC input 取指阶段的当前指令地址寄存器 32 D_PC input 译码阶段的当前指令地址寄存器 32 offset input 分支偏移量 16 instr_26 input 跳转指令的地址 26 ra_data input 返回地址寄存器数据 32 zero input 零标志信号 1 NPCOp input 下一个PC的操作码选择 3 next_pc output 计算出的下一个指令地址 32 GRF 几乎不变的模块。注意这里如果把always @(posedge)换成always @(negedge)就等同于实现寄存器内部转发。不过这种操作显得有些邪道了（），而且寄存器内部转发也不麻烦，所以我没有采用。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 RegWrite input 寄存器写使能信号 1 RA1 input 读寄存器地址1 5 RA2 input 读寄存器地址2 5 WA input 写寄存器地址 5 WD input 写入的数据 32 RD1 output 读出的数据1 32 RD2 output 读出的数据2 32 PC input 当前指令地址，用于显示 32 CMP 为了提高BEQ的运行效率特意准备的模块，小小的可爱捏。\n信号名 方向 描述 位宽 D1 input 第一个比较数据 32 D2 input 第二个比较数据 32 out output 比较结果，1表示相等，0表示不相等 1 ID_EX 这真是一个大到可怕的模块（），因为前一个步骤产生的控制信号和运算信号太多了，当然也有我为了可扩展性而加入的一些无用信号有关。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 clr input 清除信号 1 D_PC input 译码阶段的当前指令地址 32 D_PC8 input 译码阶段的当前指令地址 + 8 32 D_RD1 input 译码阶段读出的数据1 32 D_RD2 input 译码阶段读出的数据2 32 D_extimm input 译码阶段扩展后的立即数 32 D_Funct input 译码阶段功能码 6 D_rs input 译码阶段的源寄存器地址1 5 D_rt input 译码阶段的源寄存器地址2 5 D_rd input 译码阶段的目的寄存器地址 5 D_offset input 译码阶段的偏移量 16 E_PC output 执行阶段的当前指令地址 32 E_PC8 output 执行阶段的当前指令地址 + 8 32 E_RD1 output 执行阶段的读出数据1 32 E_RD2 output 执行阶段的读出数据2 32 E_extimm output 执行阶段扩展后的立即数 32 E_Funct output 执行阶段功能码 6 E_rs output 执行阶段的源寄存器地址1 5 E_rt output 执行阶段的源寄存器地址2 5 E_rd output 执行阶段的目的寄存器地址 5 E_offset output 执行阶段的偏移量 16 D_RegWrite input 译码阶段的寄存器写使能信号 1 D_ALUOp input 译码阶段的ALU操作选择信号 3 D_MemWrite input 译码阶段的内存写使能信号 1 D_WAOp input 译码阶段的写地址选择信号 2 D_WDOp input 译码阶段的写数据选择信号 2 D_BOp input 译码阶段的分支操作信号 1 E_RegWrite output 执行阶段的寄存器写使能信号 1 E_ALUOp output 执行阶段的ALU操作选择信号 3 E_MemWrite output 执行阶段的内存写使能信号 1 E_WAOp output 执行阶段的写地址选择信号 2 E_WDOp output 执行阶段的写数据选择信号 2 E_BOp output 执行阶段的分支操作信号 1 Tnew input 新数据时间信号 2 E_Tnew output 执行阶段的新数据时间信号 2 ALU 和我P4设计文档对比可以看出判断是否相等的zero信号不在ALU里实现了，因为我单独定义了CMP模块。\n信号名 方向 描述 位宽 ALUOp input ALU操作选择信号 3 A input 第一个操作数 32 B input 第二个操作数 32 ALU_res output ALU运算结果 32 EX_MEM 继续往前传。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 E_ALU_res input 执行阶段的ALU运算结果 32 E_PC input 执行阶段的当前指令地址 32 E_PC_8 input 执行阶段的当前指令地址 + 8 32 E_MemWD input 执行阶段的内存写数据 32 E_WA input 执行阶段的写地址 5 E_offset input 执行阶段的偏移量 16 M_ALU_res output 存储阶段的ALU运算结果 32 M_PC output 存储阶段的当前指令地址 32 M_PC_8 output 存储阶段的当前指令地址 + 8 32 M_MemWD output 存储阶段的内存写数据 32 M_WA output 存储阶段的写地址 5 M_offset output 存储阶段的偏移量 16 E_RegWrite input 执行阶段的寄存器写使能信号 1 E_MemWrite input 执行阶段的内存写使能信号 1 E_WAOp input 执行阶段的写地址选择信号 2 E_WDOp input 执行阶段的写数据选择信号 2 M_RegWrite output 存储阶段的寄存器写使能信号 1 M_MemWrite output 存储阶段的内存写使能信号 1 M_WAOp output 存储阶段的写地址选择信号 2 M_WDOp output 存储阶段的写数据选择信号 2 E_Tnew input 执行阶段的新数据时间信号 2 M_Tnew output 存储阶段的新数据时间信号 2 DM 不变。\n信号名 方向 描述 位宽 PC input 当前指令地址，用于显示 32 clk input 时钟信号 1 reset input 复位信号 1 MemWrite input 内存写使能信号 1 WA input 写地址 32 WD input 写入的数据 32 RD output 读出的数据 32 MEM_WB 前进。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC input 存储阶段的当前指令地址 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_MemRD input 存储阶段的内存读取数据 32 M_WA input 存储阶段的写地址 5 M_offset input 存储阶段的偏移量 16 W_ALU_res output 回写阶段的ALU运算结果 32 W_PC output 回写阶段的当前指令地址 32 W_PC_8 output 回写阶段的当前指令地址 + 8 32 W_MemRD output 回写阶段的内存读取数据 32 W_WA output 回写阶段的写地址 5 W_offset output 回写阶段的偏移量 16 M_RegWrite input 存储阶段的寄存器写使能信号 1 M_WAOp input 存储阶段的写地址选择信号 2 M_WDOp input 存储阶段的写数据选择信号 2 W_RegWrite output 回写阶段的寄存器写使能信号 1 W_WAOp output 回写阶段的写地址选择信号 2 W_WDOp output 回写阶段的写数据选择信号 2 M_Tnew input 存储阶段的新数据时间信号 2 W_Tnew output 回写阶段的新数据时间信号 2 MUX 这个模块包含了功能部件几乎所有的非跳转MUX。和各级流水线寄存器都有关。\n信号名 方向 描述 位宽 rt input 源寄存器地址2 5 rd input 目的寄存器地址 5 WAOp input 写地址选择信号 2 MemRD input 内存读取数据 32 offset input 偏移量 16 ALU_res input ALU运算结果 32 PC_8 input 当前指令地址 + 8 32 WDOp input 写数据选择信号 2 RD2 input 读出的数据2 32 Ext_imm16 input 扩展后的16位立即数 32 BOp input 分支操作信号 1 B output 选择的操作数B 32 WD output 写入的数据 32 A3 output 写入寄存器地址 5 搭建转发数据通路 转发是P5最大的难关和主要任务。因为无脑阻塞可以速杀几乎所有的问题，但为了通过评测，必须使用转发来提高运行效率！\n我对每一个接收转发的位置都构建了对应的转发模块，这使得结构清晰。\nForwardRD1 处理从E级、M级和W级到D_RD1的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 E_PC_8 input 执行阶段的当前指令地址 + 8 32 E_offset input 执行阶段的偏移量 16 E_WDOp input 执行阶段的写数据选择信号 2 D_RD1 input 译码阶段读出的数据1 32 Fwd_RD1Op input 转发选择控制信号 3 Fwd_RD1 output 转发后的数据 32 ForwardRD2 处理从E级、M级和W级到D_RD2的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 E_PC_8 input 执行阶段的当前指令地址 + 8 32 E_offset input 执行阶段的偏移量 16 E_WDOp input 执行阶段的写数据选择信号 2 D_RD2 input 译码阶段读出的数据2 32 Fwd_RD2Op input 转发选择控制信号 3 Fwd_RD2 output 转发后的数据 32 ForwardA 处理从M级和W级到E_A的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 A input 原始操作数A 32 Fwd_AOp input 转发选择控制信号 3 Fwd_A output 转发后的数据 32 ForwardB 处理从M级和W级到E_B的转发。\n信号名 方向 描述 位宽 W_WD input 回写阶段的数据 32 M_ALU_res input 存储阶段的ALU运算结果 32 M_PC_8 input 存储阶段的当前指令地址 + 8 32 M_offset input 存储阶段的偏移量 16 M_WDOp input 存储阶段的写数据选择信号 2 B input 原始操作数B 32 Fwd_BOp input 转发选择控制信号 3 Fwd_B output 转发后的数据 32 转发、阻塞信号的生成思路 我的转发和阻塞控制信号由同一个控制模块HazardUnit产生。通过输入所需要的信息，产生控制对应寄存器进行阻塞（即插入NOP指令）和控制转发模块选择正确转发数据的信号。\n信号名 方向 描述 位宽 D_RegWrite input 译码阶段的寄存器写使能信号 1 E_RegWrite input 执行阶段的寄存器写使能信号 1 M_RegWrite input 存储阶段的寄存器写使能信号 1 W_RegWrite input 回写阶段的寄存器写使能信号 1 D_rs input 译码阶段的源寄存器地址1 5 D_rt input 译码阶段的源寄存器地址2 5 E_rs input 执行阶段的源寄存器地址1 5 E_rt input 执行阶段的源寄存器地址2 5 E_WDOp input 执行阶段的写数据选择信号 2 E_WA input 执行阶段的写地址 5 M_WA input 存储阶段的写地址 5 M_WDOp input 存储阶段的写数据选择信号 2 W_WA input 回写阶段的写地址 5 Fwd_RD1Op output 译码阶段读出数据1的转发控制信号 3 Fwd_RD2Op output 译码阶段读出数据2的转发控制信号 3 Fwd_AOp output 执行阶段操作数A的转发控制信号 3 Fwd_BOp output 执行阶段操作数B的转发控制信号 3 Tuse input 当前指令的使用时间 2 E_Tnew input 执行阶段的新数据时间信号 2 M_Tnew input 存储阶段的新数据时间信号 2 W_Tnew input 回写阶段的新数据时间信号 2 IFU_en output 指令获取单元的使能信号 1 IF_ID_en output IF/ID流水寄存器的使能信号 1 ID_EX_clr output ID/EX流水寄存器的清除信号 1 转发控制思路 由于我们前面已经把控制信号沿流水线不断传递，所以我们只需要比对对应阶段的控制信号就可以得知应该是否应该转发、应该转发哪里的值。例如我对于A转发信号的产生逻辑如下。\n1 2 3 4 assign Fwd_AOp = (E_rs == 5\u0026#39;b0) ? 3\u0026#39;b011: (M_RegWrite \u0026amp;\u0026amp; E_rs == M_WA) ? 3\u0026#39;b010: (W_RegWrite \u0026amp;\u0026amp; E_rs == W_WA) ? 3\u0026#39;b001: 3\u0026#39;b000; 需要注意的是，我这里的控制信号并没有完全决定转发情况，因为我还有一部分选择是在转发模块内完成的，不过这里就不展示了。\n阻塞控制思路 使用Tuse、Tnew大法。\nTuse表示数据到了 D 级之后还需要多少个周期要使用，每个指令的Tuse是固定不变的。 Tnew表示数据还有多长时间产生，会随着数据的流水动态的减少。具体实现方法是每次Tnew经过流水线寄存器传递的时候做判断，如果非0则减1。\nHazardUnit模块会对D级的Tuse信号（因为课程要求一律在D级阻塞）和每一级的Tnew信号。如果Tuse \u0026lt; Tnew，那么说明当前需要的值还没有生成，必须阻塞流水线直到对应的值产生（即后续的Tnew通过递减与Tuse相等），反之，则说明可以通过转发解决，无需阻塞。\n测试方案 我在搭建和debug时手动编写了一系列测试样例，我把他合了起来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ori $ra, $0, 0xffff jal label add $s1, $ra, $0 label: lui $s0,1 add $s0,$s0,$s0 add $s0,$s0,$s0 add $s0,$s0,$s0 ori $s0,$0,1 jal bbb add $s0,$s0,$s0 add $s1,$s0,$s0 bbb: ori $s1,$0,1 jr $ra ori $s2,$0,1 jal aaa add $ra,$ra,$ra aaa: add $ra,$ra,$ra ori $s0,$0,2 ori $s1,$0,1 sw $s0,0($0) lw $s1,0($0) add $s1,$s1,$s1 add $s1,$s1,$s1 add $s1,$s1,$s1 ori $s1,$0,1 jal dest add $s1,$s1,$s1 add $s1,$s1,$s1 dest: add $s1,$s1,$s1 jr $ra nop ori $s0,$0,1 ori $s1,$0,1 beq $s1,$s0,dst add $s1,$s1,$s1 add $s1,$s1,$s1 add $s1,$s1,$s1 dst: add $s1,$s1,$s1 思考题 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。 答：以beq为例，我们通过提前beq的数据比较使其Tuse减为0，虽然这在控制冒险角度减少了因为默认跳转不发生需要清除的指令，但也提高了阻塞率，例如在下面这一情况：\n1 2 add $s0,$s0,$s0 beq $s0,$s1,label 因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？ 答：因为在存在延迟槽的情况下，跳转发生的时候下一条指令即PC+4指向的指令已经进入了流水线，只有写入PC+8而非PC+4，才能防止跳回时这条指令被重复执行。\n我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？ 答：因为如果转发数据来源于功能部件，这会拉长流水线寄存器间功能部件得到稳定输出值的时间，这会增大流水线的最小周期，从而限制流水线频率，影响运行效率，违背了流水线设计的初衷。\n我们为什么要使用 GPR 内部转发？该如何实现？ 答：因为当一个寄存器在流水线中同时被读写时会引发数据冒险，于是我们将即将写入寄存器的W_WD数据转发到读取寄存器的D_RD1、D_RD2，这样就实现了寄存器内部转发。\n我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？ 答：在我的CPU中，需求者是D级的寄存器读取值和E级的ALU输入值，供给者可能来自于：\nE级的16位立即数（lui）和PC+8（jal）。 M级的16位立即数（lui）、PC+8（jal）和ALU计算结果。 W级的写入数据。 转发数据通路包括：\nE到D M到D W到D M到E W到E 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。 答：我会将指令分为计算型指令、跳转型指令、访存型指令。首先是改变数据通路，和单周期类似，尽可能用现成的数据通路进行扩建（这点和P4不同，因为新增数据通路会导致必须重写大批转发）。完成数据通路之后增加对应的Tuse，Tnew和对应的控制信号。\n确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。 答：我的译码方式是集中式译码。在D级生成所有的控制信号并逐级向后传递。 优势：编写简单，速度更快，关键路径更短。 不足：没有那么模块化。\n","date":"2024-11-10T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p5-verilog%E6%90%AD%E5%BB%BA%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu/domenico-loia-hGV2TfOh0ns-unsplash_hu4086910433182145202.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p5-verilog%E6%90%AD%E5%BB%BA%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu/","title":"北航CO_P5-verilog搭建五级流水线CPU"},{"content":" 架构设计及考虑 架构设计 类图 最终程序共有22个类，其组织方式如下。\nMainClass 程序入口，调用Print进行输入解析。\nPrint 解析输入，随后调用各个方法实现功能。\nAdventure 冒险者类，因为几乎所有操作都以冒险者为主体，所以大多数功能需要这个类参与实现。\nFight 专门控制战斗的类。\nEmployment 专门控制雇佣关系的类。\nFragment 专门控制碎片的类。\nCE接口 连接冒险者游戏中的所有实体对象（均有CE）：\nAdventure Bottle父类 AtkBottle DefBottle HpBottle Equipment Guard接口 连接所有工厂中的守卫：\nShd Flm Stn Wnd Frz Treasure接口 连接所有守卫对应的宝物：\nShdTreasure FlmTreasure StnTreasure WndTreasure FrzTreasure 架构考虑 在学习了继承和接口之后，我重构了代码以增强类之间的逻辑关系，将各类药水瓶用父类形式实现，并使用接口关联起了冒险者，武器和药水瓶。在此后的工厂中也使用了接口。 对于复杂的功能，构造单独类来实现，例如Fight类，由于战斗过程复杂，单独提取出一个类，提高了代码的模块化程度。 MainClass类只用来进入程序，随后就进入Print类负责解析输入输出。 Junit心得体会 Junit单元测试是我们在OOpre课程中首次接触到的一种测试方法。他为我们提供了单独测试某个具体模块的机会，当然这机会的出现也跟java自身面向对象的特点相适应。\n在进行Junit单元测试时，我们应该进行自下而上的设计，先分别测试底层的功能能否正常实现，然后在确信底层无BUG的情况下去构造测试去测试更高层的方法，这样有利于我们快速把握问题所在。\n覆盖率是判断Junit测试有效程度的重要指标，也是OOpre课程的要求，我们今后在编写java程序时，就算没有强制要求，也应该养成保证Junit覆盖率的习惯。因为没有被测到的边边角角是最容易滋生BUG的。\nOOpre心得体会 刚开始学习OOpre的时候真的感觉非常新奇。因为面向对象编程的体验和此前完全不同。别的不说，创建一个新类后光靠代码补全就啪啪啪敲出一大堆内容的感觉真的很爽。\n不过到后期的迭代就老实了。此前我从来没有上过像OOpre这样的带有强测的课程。所以第一次需要修bug的时候真是死去活来，后面跟室友讨论才发现原来是重复携带上出了问题。不过最后一次倒是熟练了，找室友对拍了一下发现我的问题在于一次秘境探索比正常情况多闯了一关，找到对应的指令打个断点一看发现我居然携带了两个同id的药水瓶！具体问题出在哪就不说了，太丢脸。这个bug本该在第四次作业就暴露出来的。\n建议 弱测可以稍微强一点点（） ","date":"2024-11-01T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAoopre-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAoopre-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/","title":"北航OOpre-课程总结"},{"content":" 单周期CPU设计方案 概述 本次课下主要依靠P3的logisim进行翻译，不过我也对P3设计的一系列不合理之处进行了调整。我首先根据logisim电路图搭建各个模块，随后在mips.v文件中把各个模块合理地连接起来，最后添加controller模块产生控制信号。\n指令说明 本文实现的CPU在P3基础上添加了2条指令，即jal和jr。\nR型指令 add sub jr 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui J型指令 jal 空指令 nop 功能模块设计 IFU 将PC和IM合二为一。IM使用$readmehn语句读取code.txt文件里的指令。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 next_pc input 下一个指令地址 32 PC output 当前指令地址寄存器 32 instr output 当前指令 32 NPC 用组合逻辑计算出下一个指令的地址，通常是变为PC+4。根据控制信号不同会执行beq/jal/jr三种跳转。\n信号名 方向 描述 位宽 PC input 当前指令地址 32 offset input 分支偏移量 16 instr_26 input 指令中26位目标地址 26 ra_data input 从GRF返回的地址数据 32 zero input 分支条件标志 1 NPCOp input 下一地址选择操作码 3 next_pc output 计算后的下一指令地址 32 pc_add_4 output 当前地址加4的值 32 GRF 寄存器堆，同样是翻译即可。注意要display否则无法评测。\n信号名 方向 描述 位宽 clk input 时钟信号 1 reset input 复位信号 1 RegWrite input 寄存器写入使能信号 1 RA1 input 读寄存器1地址 5 RA2 input 读寄存器2地址 5 WA input 写寄存器地址 5 WD input 写入数据 32 RD1 output 读寄存器1数据 32 RD2 output 读寄存器2数据 32 PC input 当前程序计数器地址 32 DM 数据存储器，朴实无华的读写功能。同样需要display。\n信号名 方向 描述 位宽 PC input 当前程序计数器地址 32 clk input 时钟信号 1 reset input 复位信号 1 MemWrite input 内存写入使能信号 1 WA input 写地址 32 WD input 写入数据 32 RD output 读取数据 32 ALU 本文需要的指令只需要四个运算：加、减、或。相等的判断用减法实现。\n信号名 方向 描述 位宽 ALUOp input ALU操作选择信号 3 A input ALU第一个操作数 32 B input ALU第二个操作数 32 zero output 结果是否为零标志 1 ALU_res output ALU运算结果 32 MUX 这个模块的设计和每个人自身的电路设计高度相关，我认为先建立mips.v顶层文件再构造更好。具体内容在下一部分讲解。\n信号名 方向 描述 位宽 rt input 源寄存器1地址 5 rd input 源寄存器2地址 5 WAOp input 写地址选择操作码 2 MemRD input 从内存读取的数据 32 offset input 偏移量 16 ALU_res input ALU运算结果 32 pc_add_4 input 当前PC加4的值 32 WDOp input 写数据选择操作码 2 RD2 input 第二个读寄存器的数据 32 Ext_imm16 input 扩展的16位立即数 32 BOp input B选择信号 1 B output 选择的第二个操作数 32 WD output 写入的数据 32 A3 output 写入的目标寄存器地址 5 组建数据通路 verilog组建数据通路的难度远大于logisim，因为不够直观，很容易漏接某些线。我认为比较不容易出错的设计方式如下：\n将除MUX外的所有模块放入mips.v文件中并接上所有的I/O端口。为防出错，所有的接口都用同名wire连接，可以先连好再定义这些wire型变量。 观察不同模块的接口，根据自己整理的表格/P3的电路图确定哪些端口之间是一对一连接的。使用assign语句把连接到对应端口的wire变量链接在一起。 对于需要用到多路选择器的端口，我们建立一个统一的MUX模块，这个模块负责处理所有需要进行信号选择的端口。我们将所有可能的输入信号和一会用Controller.v产生的选择信号全部作为MUX的输入，所有输出信号作为输出，内部使用条件判断语句为各个输出信号赋上对应的值。随后将其添加到mips.v中。 控制信号 建立一个新的Controller.v模块，因为CPU操作只跟指令有关，所以输入只需要opcode和funct。对于其内部结构，我喜欢先为每一条指令单独定义一个wire型变量，再以这些变量为条件去编写控制信号的生成逻辑。\n信号名 方向 描述 位宽 opcode input 指令操作码 6 funct input 功能码，用于区分操作类型 6 NPCOp output 下一地址选择操作码 3 RegWrite output 寄存器写使能信号 1 ALUOp output ALU操作码 3 MemWrite output 内存写使能信号 1 ExtOp output 立即数扩展操作选择信号 1 WAOp output 写地址选择操作码 2 WDOp output 写数据选择操作码 2 BOp output 第二操作数选择信号 1 思考题 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？ 答：addr是ALU通过将寄存器值与偏移量offset相加得到的地址信号，之所以取[11:2]是因为DM的存储是以32bit为单位，而地址信号是以8bit为单位，故略去后两位使地址信号与DM内的存储地址一致。 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣 答：指令对应的控制信号如何取值： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 case (opcode) 6\u0026#39;b000000: begin // R型指令，funct决定操作 case (funct) 6\u0026#39;b100000: begin // add RegWrite = 1; ALUOp = 3\u0026#39;b000; WAOp = 2\u0026#39;b01; NPCOp = 3\u0026#39;b0; MemWrite = 0; ExtOp = 0; WDOp = 2\u0026#39;b0; BOp = 0; end 6\u0026#39;b100010: begin // sub RegWrite = 1; ALUOp = 3\u0026#39;b001; WAOp = 2\u0026#39;b01; NPCOp = 3\u0026#39;b0; MemWrite = 0; ExtOp = 0; WDOp = 2\u0026#39;b0; BOp = 0; end //略 endcase //略 endcase 控制信号每种取值时对应的指令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 assign NPCOp = beq ? 3\u0026#39;b001: jal ? 3\u0026#39;b010: jr ? 3\u0026#39;b011: 3\u0026#39;b0; assign RegWrite = add || sub || ori || lw || lui || jal; assign ALUOp = add || lw || sw ? 3\u0026#39;b000: sub || beq ? 3\u0026#39;b001: ori ? 3\u0026#39;b010: 3\u0026#39;b111; assign MemWrite = sw; assign ExtOp = ori; assign WAOp = add || sub || jr ? 2\u0026#39;b01: jal ? 2\u0026#39;b10: 2\u0026#39;b0; assign WDOp = lw ? 2\u0026#39;b01: lui? 2\u0026#39;b10: jal? 2\u0026#39;b11: 2\u0026#39;b0; assign BOp = ori || lw || sw; 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。 答：同步复位中clk信号优先级更高，只有clk上升沿到来时reset信号才有影响，而异步复位二者地位相当，二者都可以随时生效。 C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。 答：以add与addu为例，从RTL描述中可以看出，addu就是在add的基础上增加了如果运算结果最高位和次高位不相等就抛出报错，所以如果忽略这个溢出，二者就是等价的。addi和addiu同理。 ","date":"2024-10-31T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p4-verilog%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/growtika-P5mCQ4KACbM-unsplash_hu12677493546061671520.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p4-verilog%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/","title":"北航CO_P4-verilog搭建单周期CPU"},{"content":" 单周期CPU设计方案 概述 本文使用logisim搭建了一个支持八条指令的MIPS架构CPU。开发过程首先分析所需指令的RTL，抽象出所需要的功能。然后分别建模并实现恰当的功能部件。再根据不同指令之间的关系合理地组建出简洁的数据通路。最后通过构建真值表构造控制器。\n指令说明 本文实现的CPU只包含题目要求的8条指令，但笔者在使用时进行了一些操作以增强可扩展性，下文会在相应位置介绍。\nR型指令 add sub 实际上实现的指令相当于addu和subu，因为题目明确指出不考虑溢出\nI型指令 ori lw sw beq lui 空指令 nop 模块设计 PC 就是一个32位寄存器，没什么特别设计的。\n信号名 方向 位宽 Clk input 1 reset input 1 DI input 32 DO output 32 NPC 用组合逻辑计算出下一个指令的地址，通常是变为PC+4。对于跳转指令，本文只包含一个beq，但笔者为jal和jr留出了对应的接口。\n信号名 方向 位宽 PC input 32 imm16 input 16 imm26 input 26 A32 input 32 NPCOp input 2 Zero input 1 NPC output 32 GRF 寄存器堆，之前在P0已经设计过了。\n信号名 方向 位宽 Clk input 1 WE input 1 reset input 1 WD input 32 A1 input 5 A2 input 5 A3 input 5 RD1 output 32 RD2 output 32 IM 指令存储器，使用ROM实现，此前我因为审题不仔细导致这里卡了很久。要注意ROM的地址是以一个字为单位而不是字节，也就是说两个指令在mars中显示的地址是相隔4，用ROM表示其实只相隔1.\n信号名 方向 位宽 A input 12 D output 32 DM 数据存储器，用RAM实现。与指令存储器相比只多了一个写数据的功能。\n信号名 方向 位宽 Clk input 1 Wr input 1 A input 10 DI input 32 DO output 32 ALU 本文需要的指令只用得到四个运算：加、减、或和判断相等。其中等于可以用减来完成，减可以用补码来简化。\n信号名 方向 位宽 a input 32 b input 32 op input 2 c output 32 组建数据通路 取指令 PC与NPC实际上组成了一个MOORE型状态机，除这两个模块的所有部分都可以看成转移电路。\n图是gxp老师课件上的，实际电路NPC应该有几根线\n指令分解 纯粹体力劳动，把所有可能出现的指令部分全部分离出来。 ADDU \u0026amp; SUBU 最基础的指令，其他指令基本都是通过扩充这一部分的电路。 电路中rs、rt、rd分别给出读写指令，将运算的结果写入rd对应的寄存器中。 ORI 这一段稍微需要注意一下RTL。 由RTL知，我们要把立即数imm16作零扩展到32位后再参与或运算。同时，注意到这里需要输入GRF和ALU模块的信号与上面不同。rt作为了被写入的寄存器，同时进行运算的一个寄存器被换成了立即数。所以要在A3和B接口前使用MUX进行信号选择。每一次出现这类情况我们都用一个标签作为控制信号，最后使用打表方式一次性生成各指令的控制信号。 LW 首次出现了要对DM进行操作的指令。此时ALU的输出作为读DM的地址，DM的输出被写入对应寄存器中。此外，这里需要对立即数imm16进行的是有符号扩展，所以对EXT也要进行信号选择。 SW 写入而非读取，只需要加一个输入的数据信号和读/写控制信号即可。 BEQ 这一部分的逻辑主要是在NPC中完成的，此外只需要利用ALU的减法产生一个判断A、B是否相等的信号即可。 LUI 唯一老师上课没讲的指令，所以白嫖不了结构图了（悲伤）。 但实现非常简单，笔者将imm16拼接了一个16h'0的信号，然后直接连到GRF的WD端，配合MUX和控制信号即可。\n控制信号 为了使控制电路便于阅读和debug，我们使用或逻辑搭建电路，这样使得连线的目的非常明确。生成控制信号也许是最重要的一步，因为这一步很容易粗心。笔者就连错了一条。这里直接把我做的电路放上来。\n有人可能会问和逻辑呢？因为我用的是比较器所以省略掉了hhh。 跟上面的信号名不完全一样，仅供参考。\n测试数据 以下是我测试用过的数据，其中前一部分是pre给出的样例数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 .macro save(%dst) sw %dst,0($v0) lui $v1,0 ori $v1,$v1,4 add $v0,$v0,$v1 .end_macro ori $a0, $0, 123 ori $a1, $a0, 456 lui $a2, 123 # 符号位为 0 lui $a3, 0xffff # 符号位为 1 ori $a3, $a3, 0xffff # $a3 = -1 add $s0, $a0, $a2 # 正正 add $s1, $a0, $a3 # 正负 add $s2, $a3, $a3 # 负负 ori $t0, $0, 0x0000 sw $a0, 0($t0) sw $a1, 4($t0) sw $a2, 8($t0) sw $a3, 12($t0) sw $s0, 16($t0) sw $s1, 20($t0) sw $s2, 24($t0) lw $a0, 0($t0) lw $a1, 12($t0) sw $a0, 28($t0) sw $a1, 32($t0) ori $a0, $0, 1 ori $a1, $0, 2 ori $a2, $0, 1 beq $a0, $a1, loop1 # 不相等 beq $a0, $a2, loop2 # 相等 loop1:sw $a0, 36($t0) loop2:sw $a1, 40($t0) #以下为新写的 sub $v0,$v0,$v0 save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) save($0) sub $v0,$v0,$v0 lui $t0,0x7fff ori $t0,$t0,0xffff lui $t1,0xffff ori $t1,$t1,0xffff lui $t2,0 ori $t2,$t2,1 lui $t3,0x8000 ori $t3,$t3,0 add $s4,$t0,$t2 save($s4) add $s4,$t3,$t1 save($s4) sub $s4,$t0,$t1 save($s4) sub $s4,$t0,$t2 save($s4) lui $s0,0 beq $a1,$a1,equal ori $s0,$s0,0x1111 equal: ori $s0,$s0,1 save($s0) lui $s0,0 ori $s0,$s0,1 equal2: add $s0,$s0,$s0 beq $a1,$a1,equal2 save($s0) 除此之外，我还使用了大佬分享的评测机进行了测试和对拍。 以下是某一个随机生成的测试文件。 查看文档\n思考题 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。 答：发挥状态存储功能的模块：IFU、DM、GRF。发挥状态转移功能的模块：NPC、ALU、Control。 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。 答：合理，因为在本次的单周期CPU设计中，指令是只读的，所以使用只读的ROM进行存储。而DM需要频繁进行读写，所以使用RAM。GRF使用Register是标准设计，因为GRF本身就是寄存器堆，使用一堆寄存器搭建寄存器堆显然合理。此外，寄存器有高读写速度，适用于GRF的工作内容。 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。 答：没有。 事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？ 答：不需要。因为nop相当于sll $0,$0,0。即使在设置了sll指令时，因为这条指令并不改变寄存器值，也不会对运行产生影响。更别说我们这次的CPU压根没有实现sll指令。 阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。 答：总体来看相当弱。没有覆盖sub指令。对add指令测试了正正、正负、负负三种情况，较全面，但是没有针对极端值进行测试（虽然本CPU的add和sub不考虑溢出）。对于beq的测试也过于简单，没有测试offset和寄存器值为负和为0的情况。lw也没有针对$0寄存器作出检验。 ","date":"2024-10-23T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p3-logisim%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/pexels-jplenio-1105379_hu4455340264904558413.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p3-logisim%E6%90%AD%E5%BB%BA%E5%8D%95%E5%91%A8%E6%9C%9Fcpu/","title":"北航CO_P3-logisim搭建单周期CPU"},{"content":" 昨天晚上进行了计组P0的上机，他不是普通的上机，是国庆前夜的上机，是计组第一次影响分数的上机，这里除了6系牛马，没人配与他单挑。\n在去之前，我是十分焦虑的。这主要是北航CO的低容错所致：\n课程总计5.5学分，分为理论和实验两部分，其中实验部分占比超过2学分。 实验部分以课上为主，课上部分采取闯关制，只有通过前面的关卡才能继续挑战后面的关卡。例如你P5挂了，下一次上机别人做P6，你还是做P5，而且你并不是接着上一周的进度做，助教出了全新的三道题（快说谢谢助教），要是这次还不过，那下次继续。 根据往届的说法，前几次上机通过的要求都是AK,必须三道题全过，后面则会变成过两道即算通过。 上机难度通常不低，即使是那些公认的往届大佬都有不少挂过。 不过课程组也知道不能太为难学生，所以还是有一些保护措施，比如前几次上机不做卡关设置，没过也允许做后面的内容（我觉得这可能跟前几次上机不涉及迭代开发有关）。此外，据说再过几周会有一次整体的容错关，大家一起停一周，全过的同学无事可做，剩下的同学可以追一次进度。相当于提供了挂一次的容错。\n但是毫无疑问，即便如此上机依然是一个让人无比焦虑的事情，想想看，可能一个思路没转过来，就挂了一次上机，然后直接被大部队甩开，要是在同一关挂两次以上，那简直重开的心都有了。\n幸运的是，这次的P0是一个纯粹的奖励关。\n情况 我们寝室四个人都在开考后四十分钟至一个小时间AK交卷。同时，我交卷的时候仅我所在机房就有二十几个人排队在我前面等待签退，可见课程组发自内心的想让我们度过一个快乐的国庆。\n而且我们还发糖吃了，win。\n第一题 一道非常简单的组合逻辑的题目。要求计算一个四位四进制数的逆序数。\n在n个数码1，2，…，n的全排列j1j2…jn中，若一个较大的数码排在一个较小的数码的前面，则称它们构成逆序，这个排列的所有逆序的数量，称为这个排列的逆序数，记为τ(j1j2…jn)或π(j1j2…jn)。例如，在四个数码的排列3142中，3与1，3与2以及4与2都构成逆序，因此τ(3142)=3。逆序数为奇数的排列称为奇排列，逆序数为偶数的排列称为偶排列。\n这道题的思路连小学生看了上面的定义都知道，只需要从前往后依次比较六次，每次出现前大于后时加一即可。唯一可能需要注意的点就是比较器要设置为unsigned。\n第二题 一道非常简单的MOORE状态机的题目，只需要根据指令对两个寄存器进行简单的运算，00不变，01加1，10减1，11置0。有一个输入信号决定操作哪个寄存器。唯一需要注意的是操作一个寄存器时要保证另一个不变，这一点用使能端实现即可。\n第三题 一道简单的MOORE状态机的题目，需要输出由“0-9，a-f”构成的最长严格递增后缀子串的长度。\n例如，串abcdefg的后缀子串包括g,fg,efg,defg,cdefg,bcdefg,abcdefg。若一个后缀子串满足每一个数都比之前的数大，则称其为严格递增后缀子串。\n我的方法是使用两个寄存器，一个存储上一个数的值，另一个存储最长严格递增后缀子串的长度。状态更新非常简单，略而不表。\n","date":"2024-10-01T00:00:00Z","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Alogisim%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Alogisim%E7%9A%84%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/","title":"北航CO_P0课上——logisim的基础运用"},{"content":" FSM 这一题题干是检测是否输入的字符串是否符合给定的格式。\n具体格式是：先输入一到两个b，再输入两个a或c。\nIO In[1:0] I CLR I Z O 基本结构 Mealy状态机\n状态变量type 用寄存器表示\n状态0 如果输入b则状态为1，否则为0\n状态1 经过了Zebra同学的指点，我果断放弃了繁琐至极的原方法。 使用一个通用的计数器，输入b则判断计数器是否大于2，是则状态0且计数器置0，否则计数器增加，否则判断输入是否为a或c，都满足则计数器置1，状态2，否则状态0，同时计数器置0。 为什么不需要这个呢，因为这道题在连续输入b的时候无论几个都只需要保持状态1。\n如果输入b，保持状态1。 如果输入a或c，进入状态2。 否则变为状态0。\n状态2 如果输入b，进入状态1。 如果输入a或c，进入状态3，否则状态0。\n状态3 如果输入b，保持状态1。 如果输入a或c，进入状态0。\nPS：状态3其实是多余的，但是两位的寄存器放四个状态比较舒服\n复位 同步复位，使用MUX。\n子模块设置 状态转移模块 输入：type寄存器的输出和in 输出：type寄存器的输入\n输出模块 与常规Mealy状态机一样，本题是状态为2且输入为a或c即输出1。\n","date":"2024-09-26T19:32:28+08:00","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Bfsm/matt-le-SJSpo9hQf7s-unsplash_hu4699868770670889127.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco_p0%E8%AF%BE%E4%B8%8Bfsm/","title":"北航CO_P0课下——FSM"},{"content":" 花了好几个小时总算把个人博客搭好了。至于为什么要搭这个博客，只能说人终究是从众的生物，当你看到那么多6系大佬都有自己的博客，难免会想着自己搭一个。\n此外，有一说一昨天的CO上机真是一场灾难\n考试机制 每周的考试让人回忆起高中的峥嵘岁月，CO作为北航精品课程，处处都体现出了不同于其他课程的威压：\n在新北地下机房上机，禁止携带电子设备，校园卡验明真身 只能使用学校机房电脑（这意味着不能使用任何电子资料） 机房电脑手感极度糟糕1 电脑自带程序相当有限，我的vscode上配置了基础的C环境，有verilog插件和Markdown插件，然而听有些人说他们的vscode连verilog插件都没有，语法不熟悉就直接寄 这次的考试机制是总时长三小时，其中前两个小时纯自己做，最后一个小时发出提示文件，还可以向助教提问，三道题都AC之后可以点击交卷，随后助教就会过来提几个问题（然而我因为交卷太晚助教让我直接走），结束之后就可以离开了。令人惊讶的是这次上机只要在三个小时内AK，课程平台上就一律算通过，于是像我这种三道题全是最后一小时AC的大混子也有个通过标。\n第一题 第一题是一道logisim的MOORE状态机的题目，要求根据输入的不同切换数列的递推方式，这一构造没有什么难度，只要用一个额外的寄存器存储前n项和的值即可。然而这一题最大的难点在于——同步复位。\n属于是COpre魅力时刻了，因为COpre上根本没有涉及到同步复位的设计方法，我们之前做的题全部都是异步复位。于是我的设计过程是这样的：\n首先使用异步复位，即直接把reset信号练到寄存器的复位端，四个测试点过两个。 重新审题，发现需要使用同步复位，经过短暂思考，决定把clk信号和reset信号用与门连接在一起，合成同步的reset信号，然后接到寄存器的复位端。四个测试点过三个。 然后我就卡住了（允悲）。 所以问题出在哪呢？原来是因为使用与门会导致毛刺的出现，因为延时的问题，导致clk上升沿到达寄存器和clk和reset的与到达寄存器的时间有了微妙的差异，于是就会出现先正常更新一次数据再突然复位的错误现象。\n那么这个问题如何解决呢？答案是直接放弃寄存器的复位端。直接使用MUX，以reset为选择信号，reset为0时正常输入，为1时则输入初始值。这样就保证复位一定是在clk上升沿进行了。\n先写到这里，这是第一篇博客，先push一下看看显示正常不。 OK，没问题，但是我要写P0课下了，暂时先到这里 好的，这一等就是一个星期，现在是10月1号下午五点，我正在高铁上。昨天已经把P0课上考完了。\n第二题 第二题是verilog的一道非常基础的题目。几乎只是对基础语法的一个考查。整个算法只涉及一个简单的循环，如果使用vscode插件的话基础语法的正确性也有保障。然而我依然耻辱地在这一题卡了四十分钟，因为我把阻塞赋值和非阻塞赋值搞混了。\n这确实非常不应该，因为阻塞赋值和非阻塞赋值也是COpre重点描述的内容，然而我并没有认真看（允悲）。因此我对这两东西的印象就停留在always里面用非阻塞赋值，外面的就用阻塞赋值。然而事实并非如此。事实上直到现在我也没完全弄清楚（这周实在是太摆烂了），不过我的印象也升级为了组合逻辑一定用阻塞赋值（包括always @(*)内的语句，时序逻辑才用非阻塞赋值）。\n第三题 第三题与第二题定位类似，是一道极为基础的MIPS题目，代码只涉及简单的循环，条件判断。考虑到mars的help是三款软件中最简单易懂的（写语句的时候直接把意思都标出来，他真的我哭死），只要COpre学会了就不会有问题。\n总结 总而言之这次CO上机确实是非常简单，然而正是因为它太简单才显得我在考场被卡住的样子更加狼狈。不过事后我发现周围的人情况都跟我类似，大概这是第一次上机的普遍现象吧。\n黏糊糊，且有奇妙拖拽感的鼠标，不知为何看起来很不清晰的显示屏，敲起来完全不跟手的键盘……\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-24T12:10:01+08:00","image":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco%E4%B8%8A%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://messmerr.github.io/p/%E5%8C%97%E8%88%AAco%E4%B8%8A%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"北航CO上机初体验"}]